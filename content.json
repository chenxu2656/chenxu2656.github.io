{"pages":[{"title":"aboutMe","text":"个人简介 姓名 ：许许如生年龄：1999性别：男所在地：安徽合肥email: chenxu2656@gmail.comgithub：https://github.com/chenxu2656blog: www.xxrsblog.cn教育经历 2016- 安徽医科大学 生物医学工程 （Biomedical engineering ， AnHui Medical University）技能及爱好 arduino、树莓派、前端、小程序项目经历 2018- 今 图形化编程应用平台(安徽省大学生创新创业训练项目)2018- 今 图形化编程平台（面向前端开发）2019.4-今 基于webplus站群的前端主题开发 安徽医科大学财务处 安徽医科大学南校区管委会 安徽医科大学人事处 安徽医科大学纪委办公室 安徽医科大学留学生网 2019.7 用于小型场所（实验室）电子元器件及设备管理小程序 github： https://github.com/chenxu2656/celwx 比赛获奖及论文 [全国大学生电子设计大赛]（2017、2018省二等奖） [互联网+创新创业大赛]（二等奖） [大学生创新创业项目]（安徽省立项） [安徽省禁毒辩论赛]（♥champion♥） Zhen Liang, Runhuai Yang*, Chenchen Xu, Shaohui Hou, Guoqing Jin and Fuzhou Niu. The Simulation and Experiment Study of a Wearable, Flexible and Transparent Biomimetic Voltage Source. In: Okada H., Atluri S. (eds) Computational and Experimental Simulations in Engineering. ICCES 2019. Mechanisms and Machine Science, vol 75. Springer, Cham [软件著作权] [心理学可视化编程云平台]（2019SR0596271 第一著作权人） [仪器管理平台]（2019SR1312933 第一著作权人） [专利] [一种静脉输液辅助装置]（201920661185.9） 其他 考研估计要凉，学学前端找工作啦！！！","link":"/about/index.html"},{"title":"donate","text":"如果对您有帮助 请代我向中国红十字会捐赠 捐款地址 https://mv.lingxi360.com/m/zjgw7x?utm_bccid=LXEhue1n","link":"/donate/index.html"}],"posts":[{"title":"Tcp的三次握手和四次挥手","text":"一、TCP的三次握手及相关问题 1. TCP报文段首部格式 序号seq(sequence number): 表示本报文段所发送的数据的第一个字节序号 比如序号字段值是301，携带的数据共有100个字节，表示本报文段数据的第一个字节的序号是301 确认号ack(acknowledge number)：表示期望收到对方下一个报文段的第一个数据字节的序号 比如 B收到A发来的报文中： 序号的字段值是501（序号表示的是数据的第一个字节序号），数据长度是200 则：B收到了序号为501-700的数据—-&gt;说明 B期待收到的下一个数据的序列号应该是 701 于是：B把返回给A的报文中 确认号（ack）设置为701 确认ACK(AXKnowlegment)： 仅仅当ACK为1时该字段才有效，建立连接后所有传送的报文段都必须把ACK置1 同步SYN(Synchronize Sequence Numbers) 在建立连接时用来同步序号 SYN=1 ACK=0 表示是连接请求报文段 SYN=1 ACK=1 表示对方同意建立连接 终止FIN(FINis) 用来释放一个连接 FIN = 1时表示要求释放连接 2. tcp三次握手详解 客户端的初始状态是 closed 服务端的初始状态是 listen 2.1 第一次握手 客户端给服务端发送请求报文段 此报文段的同步位 SYN = 1 ，表示这是一个请求报文段 随机生成一个序列号 seq = x； 随机生成一个序列号是为了网络安全，如果序列号不是随机的容易被黑客获取到初始序列号 客户端的状态变成： SYN_SEND(同步已发送) 这个报文段不能携带数据 2.2 第二次握手 服务端同意建立连接 SYN = 1 , ACK = 1 表示同意建立连接 确认号是 ack = 1 ; 随机生成一个初始序号 seq = y; 不携带数据 服务端状态变成 SYN_RCVD(同步已收到) 2.3 第三次握手 客户端再次向服务端给出确认 AXK = 1 确认号 ack = y + 1 ; seq = x + 1 ; 客户端状态变成 ESTABLISHED 当服务端收到确认后也变成 ESTABLISHED 3. 为什么要三次握手，三次握手功能 第一次握手可以确认： 客户端发送数据功能正常 (A发出信号) 第二次握手可以确认： 服务端接收和发送功能均正常(B确认喜欢A，并发出信号) 第三次握手可以确认： 客户端接收功能正常（第三个阶段才能确认A也喜欢B，第一个阶段并不能确认A喜欢B，第一个阶段A只是问了B） 4. 半连接队列和全连接队列 第一次受到client的SYN之后，server处于SYN_RCVD状态，此时双方还没有完全建立连接，server会把这种状态下的请求连接放在一个队列里，称为半连接队列 已经完成三次握手之后，建立起的连接会放在全连接队列中，如果队列满了可能会出现丢包，这样的队列称为全连接队列 server发送SYN和ACK包的重传：服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…… 5. 三次握手中可以携带数据吗 第一次和第二次握手不可以携带信息，第三次可以携带信息，前两个阶段不可以携带信息。因为第三次握手的时候客户端才是ESTABLISHED状态，就上面那个生动的图来讲，只有第三次握手你确定了互相喜欢才可以携带一些信息（比如一起看电影、约会） 6. SYN 和 SYN 攻击 SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，常用假冒的IP或IP号段发来海量的请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量SYN_RECV状态的“半连接”，并且会重试默认5次回应第二个握手包，塞满TCP等待连接队列，资源耗尽（CPU满负荷或内存不足），让正常的业务请求连接不进来。 TCP的四次挥手及相关问题 1. 四次挥手详解 1.1 第一次挥手 client发出连接释放报文段 FIN = 1 (要求释放连接) seq = u 前面传输数据的最后一个字节加1 client状态：FIN_WAIT1(终止等待1、等待server确认) 1.2 第二次挥手 server接收到释放报文段后发出确认 （这时候 client —&gt; server方向连接断了） ACK = 1 ack = u + 1 ; seq = v ; 已经发送的数据的最后一个字节序号加1 server 进入CLOSE_WAIT(等待关闭状态) client 进入FIN_WAIT2(终止等待2状态)，等待server发出释放确认报文段 这时候CLIENT-SERVER的连接释放了，这时候与的TCP处于办关闭状态(half-close),这时候client已经没有数据要发了，但是这时候server还有可能向client发送数据 1.3 第三次挥手 这时候server发出连接释放报文段（想让 server—&gt;client方向连接断掉） FIN = 1; 重复发送确认报文段： ACK = 1; ack = u + 1; server状态： LAST_ACK 等待A确认 1.4 第四次挥手 client同意与server断开连接 ACK = 1; client状态： TIME_WAIT 在2MSL之后变成CLOSED server状态： CLOSED 1.5 通俗解释一下 2. 为什发送端需要等待 2MSL后关闭 MSL:(Maximum segment lifetime)最长报文寿命为什么要等待两个msl？ 1.保证client发送的ACK可以成功到达server，如果client发送完就close了，万一报文丢失，server收不到client发来的ACK，就会超时重新进行第三次挥手，这个时间就是2MSL:即：超时等待时间+再次进行第三次挥手的事件 2.防止“已失效的连接请求报文段”出现在本连接中。客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段 3. 为什么第二次挥手和第三次挥手不能合并 细心的同学发现，所谓四次挥手中的第二次和第三次就是把握手中的第二次拆来了。为什么不能合并？ 因为挥手过程和握手过程不同，前两次握手是不携带数据的只处理连接问题。挥手不仅要解决连接问题，还要解决数据传输问题，第二次挥手后，client只是不能发送数据了，但是并不说明不能接受数据。server可能还有数据要给client。所以二三两次不可以合并 引用博客 本篇博客主要是在这篇博客基础上的修改：https://segmentfault.com/a/1190000020610336#item-1-4 参考文档 https://blog.csdn.net/u014507230/article/details/45310847 https://blog.csdn.net/lengxiao1993/article/details/82771768 https://blog.csdn.net/qq_36865108/article/details/84885506 https://www.jianshu.com/p/7d0f91345483 https://cloud.tencent.com/developer/article/1115567 https://blog.csdn.net/wudiyi815/article/details/8505726 http://jm.taobao.org/2017/05/25/525-1/ https://www.jianshu.com/p/bbb6261cb13e 书本才是最权威易懂的 《谢希仁计算机网络第六版》 转载标明链接哦","link":"/2020/01/05/TcP%E6%8C%A5%E6%89%8B%E6%8F%A1%E6%89%8B/"},{"title":"px、rem、em区别","text":"px：绝对单位 不随设备改变 em：相对于父元素倍数 rem：相对于根元素倍数","link":"/2020/01/02/cssSize/"},{"title":"css 权重","text":"!important&gt;行内样式&gt;ID选择器 &gt; 类选择器 | 属性选择器 | 伪类选择器 &gt; 元素选择器 1234567891011121314151617181920212223&lt;style&gt;div#test1{ background-color: blue;}#test1{ /* id 的权重是100 */ background-color: green;}.test{ /* 类的权重为10 */ background-color: brown;}div{ /* 元素选择器的权重是 1 */ background-color: hotpink;}&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;test1&quot; class=&quot;test&quot; style=&quot;width: 200px; height: 200px;&quot;&gt; &lt;/div&gt;&lt;/body&gt;result : background-color: blue; css多用类js多用id","link":"/2020/01/01/cssweight/"},{"title":"电桥电路分析方法","text":"👉 https://zhuanlan.zhihu.com/p/32111487","link":"/2019/12/26/dianqiao1/"},{"title":"docker修改映射端口号","text":"大家都知道docker run可以指定端口映射，但是容器一旦生成，就没有一个命令可以直接修改。通常间接的办法是，保存镜像，再创建一个新的容器，在创建时指定新的端口映射,但是这种方法比较麻烦。牛人还是有奇招的：https://stackoverflow.com/questions/19335444/how-do-i-assign-a-port-mapping-to-an-existing-docker-container 停止容器 1docker stop containerID 停止docker服务 1systemctl stop docker 修改这个容器的hostconfig.json文件中的端口（如果有多个版本都需要修改） centos一般默认的docker container目录在这进入这个目录 1cd /var/lib/docker/containers/8bee1db654916998ae2e4c716481209f290d521b74dc997bbd37cb8d9f856cc4 1vi hostconfig.json 修改下面这个端口号就行，这里我已经修改过了 启动docker服务1systemctl start docker 5) 启动容器 1docker start containerID 如果修改完之后没有正常运行，请检查原有的服务是否开启，因为有时有的服务需要重启一下","link":"/2019/12/25/docker3/"},{"title":"centos7配置docker","text":"docker主要分为两个版本 docker CE (社区免费版) docker EE(收费版本)，我们使用社区免费版就行 安装一些必要的系统工具： 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息： 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存： 1sudo yum makecache fast 安装 Docker-ce： 1sudo yum -y install docker-ce 启动 Docker 后台服务 1sudo systemctl start docker 测试运行 hello-world 1docker run hello-world (先自动安装helloword的库然后运行) 查询docker版本 1docker -v","link":"/2019/12/25/docker1/"},{"title":"doracms 部署（node+mongodb的高性能服务器）基于docker","text":"==1. doracms==github：https://github.com/doramart/DoraCMS 官网：https://www.html-js.cn/ ==2. 安装docker== docker主要分为两个版本 docker CE (社区免费版) docker EE(收费版本)，我们使用社区免费版就行 安装一些必要的系统工具： 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息： 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存： 1sudo yum makecache fast 安装 Docker-ce： 1sudo yum -y install docker-ce 启动 Docker 后台服务 1sudo systemctl start docker 测试运行 hello-world 1docker run hello-world (先自动安装helloword的库然后运行) 查询docker版本 1docker -v ==3.安装doracms== 查询 DoraCMS 镜像 1docker search doracms 下载 DoraCMS 镜像 1docker pull doramart/doracms:2.1.2 查询镜像是否下载成功 1docker images 通过doracms镜像创建mycms 容器，并制定映射端口号*(==请在服务器打开你映射的端口否则可能无法访问==) 1docker run -it -d -p 8001:8080 --name mycms doramart/doracms:2.1.2 /bin/bash 查看端口号绑定情况： 1docker ps 开启redis 1redis-server /etc/redis/redis.conf &amp; 开启mongodb 123cd /usr/local/mongodb/mongodb-linux-x86_64-ubuntu1604-4.0.9/bin/./mongod --config /usr/local/mongodb/mongodb.conf 进入代码根目录，重装依赖（本身镜像中有依赖，建议删除重新安装一次），依次执行下面的命令 1234567cd /home/webapp/DoraCMS/git pullrm -rf node_modules/npm i 让环境变量生效,镜像中在 /etc/profile 中配置了 export NODE_ENV=production, 但是需要source一下使其生效： 1source /etc/profile 通过pm2 启动项目 1pm2 start server.js --name doracms 在本地通过 http://localhost:8001 访问，可以看到，页面已经打开了。 ==4. 常见问题==重启服务器网站无法访问 我做了一个快照，但是重启服务器后网站无法访问，猜测是某些服务没打开，但是不知道是哪些服务没开，所以试着开一下所有服务 打开进入容器 12docker start containerIDdocker attach containerID 查一下运行状态 1pm2 list 发现是空的 我用Pm2重启服务之后发现还是打不开，然后我就跟着安装步骤把每个服务都重启了一下发现可以运行了。开启redis 1redis-server /etc/redis/redis.conf &amp; 开启mongodb123cd /usr/local/mongodb/mongodb-linux-x86_64-ubuntu1604-4.0.9/bin/./mongod --config /usr/local/mongodb/mongodb.conf 进入代码根目录1cd /home/webapp/DoraCMS/ 让环境变量生效,镜像中在 /etc/profile 中配置了 export NODE_ENV=production, 但是需要source一下使其生效：1source /etc/profile 通过pm2 启动项目1pm2 start server.js --name doracms","link":"/2019/12/26/doracms/"},{"title":"arduino(UNO、MEGA、DUE、Leonardo、YUN)-TFT接线方法","text":"==1. TFT引脚图== ==2. 各种板子的软件SPI== ==3. 接线及引脚==3.1 UNO接线 引脚 +5V: +5V MISO: pin 12 SCK: pin 13 MOSI: pin 11 LCD CS: pin 10 SD CS: pin 4 D/C: pin 9 RESET: pin 8 BL: +5V GND: GND 3.2 Leonardo、YUN接线 引脚 +5V: +5V MISO: Miso pin (white wire on ICSP) SCK: Sck pin (brown wire on ICSP) MOSI: Mosi pin (yellow wire on ICSP) LCD CS: pin 7 SD CS: pin 8 D/C: pin 0 RESET: pin 1 BL: +5V GND: GND 3.3 mega2560接线 引脚 +5V: +5V MISO: 50 on Mega 2560 (Miso on ADK) SCK: 52 on Mega 2560 (Sck on ADK) MOSI: 51 on Mega 2560 (Mosi on ADK) LCD CS: pin 10 SD CS: pin 4 D/C: pin 9 RESET: pin 8 BL: +5V GND: GND 3.4 Leonardo、YUN接线 引脚 +5V: +5V MISO: Miso pin (white wire on SPI) SCK: Sck pin (brown wire on SPI) MOSI: Mosi pin (yellow wire on SPI) LCD CS: pin 10 SD CS: pin 7 D/C: pin 9 RESET: pin 8 BL: +3.3V GND: GND ==4. 程序初始化模板== mega 2560为例 12345678910111213141516171819#include &lt;Arduino.h&gt;#include &lt;TFT.h&gt; // Arduino LCD library#include &lt;SPI.h&gt;#define cs 10#define dc 9#define rst 8TFT TFTscreen = TFT(cs, dc, rst);void setup() { // initialize the display TFTscreen.begin(); // black background TFTscreen.background(0,0,0); TFTscreen.stroke(255,255,255); //设置文字颜色为白色 TFTscreen.setTextSize(2); //设置显示文字大小 }void loop() { TFTscreen.stroke(255, 0, 0); // set the stroke color to red TFTscreen.line(0, 10, TFTscreen.width(), 10); // draw a line across the screen}","link":"/2019/12/26/arduino/"},{"title":"docker常用命令","text":"查询镜像1docker search IMAGENAME 下载镜像 1docker pull IMAGENAME 查询已下载镜像 1docker images 查询容器列表 1docker ps 删除一个容器实例 1sudo docker rm CONTAINERID 删除所有容器 1sudo docker rm sudo docker ps -aq 停止一个正在运行的容器 1sudo docker kill CONTAINERID 重启一个正在运行的容器 1sudo docker restart CONTAINERID 开启一个已经停止的容器 1sudo docker start CONTAINERID 删除镜像，从本地删除一个已经下载的镜像 先查看正在运行的 容器 1docker ps 结束正在运行的容器 1docker kill containerid 删除正在运行的容器 1docker rm CONTAINERID 删除镜像 1docker rmi imageid ==注意 rm 和 rmi 分别用来删除容器和镜像== 退出当前镜像1exit","link":"/2019/12/25/docker2/"},{"title":"基于node+mongodb的简易服务器搭建（window）配合ESP8266进行物联网","text":"准备工作 在磁盘根目录下新建一个文件夹 server (避免路径出现中文报错)，然后server下新建两个文件夹 node、mongodb 把这两个安装包下载下来(直接点击下载，用了CDN比官网快) node.js : http://files.qianduan.ltd/node-v8.12.0-x64.msi mongodb : http://files.qianduan.ltd/mongodb-win32-x86_64-2008plus-ssl-4.0.9-signed.msi 安装node.js node 安装比较简单，主要注意安装路径 1. 安装目录选中到刚才的 server/node 2. 测试是否安装成功 12345win+R 打开运行输入 cmdnode -v //查询安装版本号 出现版本号则说明成功 安装mongodb1. 安装路径选择 server/mongodb 2. 关于数据和日志 这一部分主要用于设置用户密码，数据日志，这里mongo做了改进以前还需要手动创建，这里我们保持默认就行，本地测试不需要设置密码 3. 取消勾选图形界面 取消勾选，否则会装不上。如果大家想试一下可以在vscode安装mongodb插件相关插件也非常好用 4. 测试 进入目录 F:\\server\\mongodb\\bin 运行 mongo.exe 1show dbs //查看所有数据库 mongodb安装端口是 27017 访问 127.0.0.1:27017 运行服务器文件准备 首先下载我写好的服务器文件http://files.qianduan.ltd/DS-WEB.rar并解压，把解压好的服务器文件整个复制到 server文件夹下文件目录： public存放静态文件（一定要放在public下，否则node报错） index.js 服务器配置文件 index.html 前端主页1. 安装引入的模块（及把index.js里面require的模块给安装下来） 大家自行查看js文件可以看到我们引入了哪些3模块，我做了简单的注解 1. 进入DS-WEB文件夹，输入cmd回车进入命令行2. 分别执行以下代码 1234567891011121314// 事件监听npm install events // 操作数据库的工具npm install mongoosenpm install netnpm install body-parsernpm install expressnpm install http// 事件发射器 可实现双向通信npm install socket.io 3.重开命令窗口运行 node index.js可以看到服务器应在在运行 端口号 3000 监听硬件端口号 8000 最下面是我的web板子，可以看到已经连接上我的服务器 4. 进入浏览器打开 localhost:3000 服务器已经正常运行 5. 安装进程管理工具 这时候我们把node的命令框关掉然后刷新网页发现已经不能运行了,所以我们安装一个进程管理工具来保障服务运行，进行管理工具有很多 比如 forever、pm2我比较习惯用pm2123win+R ---&gt; cmd ---&gt;进入黑框框npm install pm2 -g 进入DS-WEB文件夹，进入命令框用pm2启动服务1pm2 start index.js 可以看到服务正在运行 6. 补充几个pm2常用命令123pm2 start X //启动服务pm2 stop X //停止服务pm2 list // 服务列表","link":"/2019/12/26/dsweb/"},{"title":"javascript遍历json数组","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;动态表格&lt;/title&gt;&lt;/head&gt;&lt;style&gt; table { border-collapse: collapse; } tr { height: 30px; } th, td { width: 150px; border: 1px solid black; text-align: center; } .deletData { color: red; }&lt;/style&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;学科&lt;/th&gt; &lt;th&gt;分数&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; var data = [ { name: '魏璎珞', item: 'javascaript', grade: '100', operation: 'deleteDate' }, { name: '弘历', item: 'javascaript', grade: '10', operation: 'deleteDate' }, { name: '傅恒', item: 'javascaript', grade: '1000', operation: 'deleteDate' }, { name: '明玉', item: 'javascaript', grade: '99', operation: 'deleteDate' }, { name: '大猪蹄子', item: 'javascaript', grade: '99', operation: 'deleteDate' } ] var tableDate = document.querySelector('table'); for (var i = 0; i &lt; data.length; i++) { var creatItem = document.createElement('tr'); tableDate.appendChild(creatItem); // 遍历 json for (allCon in data[i]) { var creatTd = document.createElement('td'); // console.log(allCon) creatTd.innerHTML = data[i][allCon]; creatItem.appendChild(creatTd); if (allCon == 'operation') { // 给删除加一个删除类 creatTd.className = 'deletData'; } } } // 点击删除后删除节点 var deletDataButton = document.querySelectorAll('.deletData'); // console.log(deletDataButton.length); for (var z = 0; z &lt; deletDataButton.length; z++) { deletDataButton[z].onclick = function () { // 点击触发 var flag = confirm('请谨慎删除,确定是否要删除？'); if (flag) { var shouldDelet = this.parentNode; shouldDelet.parentNode.removeChild(shouldDelet); } else { alert('未删除'); } } }&lt;/script&gt;&lt;/html&gt;","link":"/2019/12/27/javacriptJson/"},{"title":"http 和 https","text":"https://juejin.im/post/5a8102e0f265da4e710f5910 http (hyperText transfer protocol) 超文本传输协议 特点 超文本传输协议用于web浏览器和网站服务器之间传递信息， 以明文方式发送内容，不进行任何加密，所以不适合传输一些敏感信息 一般而言 端口是80 http无连接 每次连接服务器处理完客户请求立即断开连接，节约传输时间 http无状态协议 https://blog.csdn.net/tennysonsky/article/details/44562435 对事务处理没有记忆能力，就是当客户端一次完成请求之后再次发送请求是http并不知道是一个老用户 可以通过cookie解决这个问题 https (hyperText transfer protocol secure) 安全的超文本传输协议 在http中加入SSL层 SSL (secure sockets layer) ssl：为网络通信提供安全及数据完整性的一种安全协议 在传输层和应用层之间对网络进行加密 认证用户和服务器，确保数据发送到正确的客户机和服务器 加密数据放置中途窃取 维护数据完整性，确保数据在传输过程中不被改变 加密在传输层实现 https端口为443 工作步骤 客户端使用https的URL访问服务器，要求服务器建立SSL连接 web服务器接受到客户端的请求后，会将网站的证书（证书中包含了公钥）传输给客户端 客户端和web服务器协商ssl链接的安全等级 也就是加密等级 客户端和浏览器通过双方协商一致的安全等级 建立会话秘钥，然后通过公钥加密会话秘钥，传给网站 web服务器通过私钥解密出会话秘钥 web服务器通过会话秘钥加密与客户端之间的通信 缺点 握手比较费时，使页面加载时间延长50% 不如http高效 SSL证书需要绑定IP","link":"/2020/01/04/http/"},{"title":"Javascript选择器","text":"1. 获取某个Id1getElementById('idName'); 2. 获取某个 ClasaName1getElementByClassName() 3. 根据标签名获取返回的是一个伪数组 1getElementByTagName() 4. 获取body 返回的是 节点 1Document.body 5. 获取html对于任何非空 HTML 文档，调用 document.documentElement 总是会返回一个 元素，且它一定是该文档的根元素。借助这个只读属性，能方便地获取到任意文档的根元素。 1document.documentElement 6. querySelector需要指明name的具体属性 比如 #name .name 等返回的是制定选择器的第一个元素对象 1querySelector(&quot;name&quot;) 7. querySelectorAll需要指明name的具体属性 比如 #name .name 等返回的是制定选择器所有对象集合（一个数组） 1querySelectorAll(&quot;name&quot;)","link":"/2019/12/26/javascript1/"},{"title":"javascript节点操作","text":"1. 节点类型基础常用 元素节点 nodeType = 1 = 常用 属性节点 nodeType = 2 文本节点 nodeType = 3 注释节点 nodeType=8 节点三个基本属性 nodeType 代表不同的节点类型 nodeName 对于元素节点，nodeName=标签名（返回的名称是大写的） 对于文本节点，nodeName=’#text’ nodeValue 对于文本节点，nodeValue=文本内容 对于元素节点，返回undefined 因为元素节点本身不含内容 1234567891011121314151617181920//示例代码&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 下面输出为3 包含两个文本节点和一个元素节点 console.log(obj.childNodes); // 输出 #text console.log(obj.childNodes[0].nodeName); // 输出 LI console.log(obj.childNodes[1].nodeName); // 输出 你好不好反正我不好 console.log(obj.childNodes[0].nodeValue); // 输出 undefined console.log(obj.childNodes[1].nodeValue);&lt;/script&gt; 2. 获取父节点1. element.parerntNode123456789101112&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('li'); console.log(obj.parentNode); // parentElement 一般和parentNode一样，只有nodeType!==1的时候，即父节点不是Element的时候，通过parentElement得到的父节点会是null； console.log(obj.parentElement);&lt;/script&gt; 输出 1234&lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;/div&gt; 3. 获取子节点 children 只返回 元素节点 非常好用 childNodes 会获取包含元素、文本等所有节点 返回一个数组 不常用 12345678910111213&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // childNodes 会获取包含元素、文本等所有节点 返回一个数组 不常用 console.log(obj.childNodes); // children 只返回 元素节点的数组 非常好用 console.log(obj.children);&lt;/script&gt; 4. 获取第一个子节点和最后一个节点 children[0] 返回元素节点的数组 数组第一个元素 fisrstchild 会把第一个文本节点也包含起来 并不是很好用 firstElementChild只返回第一个元素节点 非常好用 12345678910111213141516&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;li&gt;拜拜啦您嘞&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // children 返回元素节点的数组 数组第一个元素 console.log(obj.children[0]); // Fisrstchild会把第一个文本节点也包含起来 并不是很好用 console.log(obj.firstChild); // firstElementChild只返回第一个元素节点 非常好用 console.log(obj.firstElementChild);&lt;/script&gt; 把first换成last就可以得到最后一个节点5. 获取兄弟节点 nextSibling 下一个节点 会包含各种节点 nextElementSibling 只会获取下一个元素节点 previousSibling 上一个节点 会包含各种节点 previousElementSibling 只会获取上一个元素节点 6. 创建、添加、删除节点 creatElememt(‘tagname’) 创建节点 Node.AppendChild(child) 在node父节点的最后添加一个子节点 相当于 push Node.insertBefore(child,指定子节点) 在node父节点中的指定子节点之前添加子节点 Node.removeChlid(child) 删除指定节点 1234567891011121314151617181920212223&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 选择原有节点 var firstLi = document.querySelector('li'); console.log(firstLi); // 创建一个节点 var newLi = document.createElement('li'); newLi.innerHTML='2' // 插入节点 默认会在最后插入 obj.appendChild(newLi); // 新创建一个节点 var newLi2 = document.createElement('li'); newLi2.innerHTML='0' // 指定位置插入节点 把新创建的newLi2节点插入到 firstLi前面 obj.insertBefore(newLi2,firstLi); // 删除指定节点 obj.removeChild(firstLi);&lt;/script&gt; 7. 克隆节点 node.cloneNode(deep); deep==false或者留空 浅拷贝 , deep==true 深拷贝 12345678910111213141516&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 选择原有节点 var firstLi = document.querySelector('li'); // cloneNode(参数1) 参数1默认是 false 当留空或者是false时 默认浅拷贝 var clone1 = firstLi.cloneNode(); // cloneNode(true) 深拷贝 会拷贝内部内容 var clone2 = firstLi.cloneNode(true); obj.appendChild(clone1); obj.appendChild(clone2);&lt;/script&gt;","link":"/2019/12/27/javascriptJieDian/"},{"title":"javscript 鼠标事件","text":"js鼠标事件汇总 事件触发事件源+事件类型+事件处理程序 12345var shijianyuan = document.getElementById('tijiao'); // 事件源shijianyuan.onclick = function(event){ // onclick 为事件触发类型 // function 内为事件触发函数} 触发时的参数event为MouseEvent对象类型： 123456789# 示例程序返回点击时鼠标的坐标&lt;body&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log(MouseEvent.x); } &lt;/script&gt;&lt;/body&gt; offsetY 、 screenY 、 clientY (y) 、 pageY的区别12345678910111213141516&lt;body style=&quot;height: 2000px;&quot;&gt; &lt;html&gt; &lt;div style=&quot;width: 500px; height: 500px; background-color: aqua; margin: 200px auto auto 200px; padding: 100px;&quot;&gt; &lt;div style=&quot;width: 200px; height: 200px; background-color: brown;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/html&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log('clienty的坐标是'+MouseEvent.y); console.log('pagey的坐标是'+MouseEvent.pageY); console.log('offsety的坐标是'+MouseEvent.offsetY); console.log('screeny的坐标是'+MouseEvent.screenY); } &lt;/script&gt;&lt;/body&gt; 运行结果 offsetY相对于父节点的位置而言 screenY相对于整个显示器的位置而言 clientY相对于当前页面的位置而言 offsetY相对于当前页面+纵向滚动距离（）的位置而言","link":"/2019/12/27/javascriptMouse/"},{"title":"javascript选择器","text":"元素获取方法汇总 获取某个Id1getElementById('idName'); 获取某个 ClasaName1getElementByClassName() 根据标签名获取返回的是一个伪数组 1getElementByTagName() 获取body 返回的是 节点 1Document.body 获取html对于任何非空 HTML 文档，调用 document.documentElement 总是会返回一个 元素，且它一定是该文档的根元素。借助这个只读属性，能方便地获取到任意文档的根元素。 1document.documentElement querySelector需要指明name的具体属性 比如 #name .name 等返回的是制定选择器的第一个元素对象 1querySelector(&quot;name&quot;) querySelectorAll需要指明name的具体属性 比如 #name .name 等返回的是制定选择器所有对象集合（一个数组） 1querySelectorAll(&quot;name&quot;)","link":"/2019/12/27/javascriptSelect/"},{"title":"addEventListener(event, function, useCapture)","text":"1. 事件注册方式 onclick 和 addEventListener 1. 事件源+事件类型 = 事件处理程序 (for example : onclick ..)123obj.div = function(){ alert('1');} 缺点：无法同时绑定多个事件 比如下面这个程序，同时绑定两个事件，但是却只能触发后面一个，即只弹出 ‘2’ 1234567891011121314&lt;body&gt; &lt;div class=&quot;Class&quot; style=&quot;width: 200px; height: 200px; background-color: blue; margin: 200px auto auto 200px;&quot; &gt; &lt;li&gt;1&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); obj.onclick = function(){ alert('1'); } obj.onclick = function(){ alert('2'); }&lt;/script&gt; 2. addEventListenerelement.addEventListener(event, function, useCapture) 兼容性 &gt;ie9 (&lt; ie9 could be replaced by attachEvent() ) 可以注册多个事件 三个参数 type: 事件类型的字符串 click 、 mouseover 等 注意不要加 on listener:事件处理函数 useCapture ： 一个布尔类型值 默认是flase flase ： 按照事件冒泡方式处理程序 true ：按照事件捕获处理程序12345678910111213141516171819202122232425&lt;body&gt; &lt;div class=&quot;Class&quot; style=&quot;width: 200px; height: 200px; border: 1px solid red;&quot; &gt; &lt;li style=&quot;height: 50px; width: 100%; background-color: blue; &quot;&gt;1&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); var objLi = document.querySelector('li'); //如果 useCapture == false 会按照事件冒泡执行 // 即： 先弹出 ‘我是子元素’ 后弹出 “我是父元素” obj.addEventListener('click',function(){ alert('我是父元素'); },false) objLi.addEventListener('click',function(){ alert('我是子元素'); },false) // //如果 useCapture == true 会按照事件冒泡执行 // // 即： 先弹出 ‘我是父元素’ 后弹出 “我是子元素” obj.addEventListener('click',function(){ alert('我是父元素'); },true) objLi.addEventListener('click',function(){ alert('我是子元素'); },true)&lt;/script&gt; 3. attachEventtarget.attachEvent(eventNameWithOn, callback) ie9 之前 而且只能用在ie9之前 事件之前要加 on 4. 兼容性处理12345678910// 封装一个兼容函数 var addEvent = function (target,eventName,fn) { if(addEventListener){ target.addEventListener(eventName,fn); }else if(attachEvent){ target.attachEvent('on'+eventName,fn); }else{ target['on'+eventName] = fn; } } 2. 取消事件监听 事件解绑 1. target.onclick=null;12345var obj = document.querySelector('div'); obj.onclick = function(){ alert('调用成功'); this.onclick= null; } 2. target.removeEventListener(‘click’,fn);1234567var obj = document.querySelector('div');function func(){ alert('调用成功'); this.removeEventListener('click',func)}// 封装一个兼容函数obj.addEventListener('click',func) 3. target.detachEvent(‘click’,fn)对应 attachEvent 4. 封装一个兼容函数1234567891011121314151617var obj = document.querySelector('div'); function func(){ alert('调用成功'); disListener(obj,'click',func); } obj.addEventListener('cilck',func) // 封装一个兼容函数 obj.addEventListener('click',func) function disListener(target,eventName,func){ if(removeEventListener){ target.removeEventListener(eventName,func); }else if(detachEvent){ target.detachEvent('on'+eventName,func); }else{ target['on'+eventName]= null; } }","link":"/2019/12/28/jsAddEvent/"},{"title":"javascript修改页面css样式","text":"1.element.style 不会清除原来的任何属性 123456789101112131415161718&lt;style&gt;.oldClass{ color: red;}&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;oldClass&quot; style=&quot;width: 200px ;height: 200px; border: red 1px solid;&quot;&gt; hi xuxurusheng &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector('div'); div.onclick = function (){ this.style.backgroundColor='yellow'; }&lt;/script&gt;// 直接使用 element.style// 注意后面属性（backgroundColor）是驼峰命名法 2. cssText 不会清除内部属性，但是回去清除内嵌属性 12345678910111213141516171819202122&lt;style&gt;.oldClass{ color: red;}&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;oldClass&quot; style=&quot;width: 200px ;height: 200px; border: red 1px solid;&quot;&gt; hi xuxurusheng &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector('div'); div.onclick = function (){ this.style.cssText=&quot;background-color:yellow&quot;; // 这样写会把内嵌样式给替换掉 运行结果是 红字黄底 但是宽高都没有了 }&lt;/script&gt;``` ## 3. obj.className 来修改或者增加元素类 ---会替换掉原来的内部样式，但是不会替换掉内嵌样式。如果想保留原来的类可以用空格把几个类都隔起来 .oldClass{ color: red; } .newClass{ background-color: yellow; } hi xuxurusheng var div = document.querySelector('div'); div.onclick = function (){ // 这种方法文字颜色会为黑色 背景会变成黄色 this.className='newClass'; // 这种方法文字颜色不会为黑色，还是红色。 背景会变成黄色 this.className='oldClass newClass'; // 这两种方法都不会改变 style=\"width: 200px ;height: 200px; border: red 1px solid;\" 这一内嵌样式 } 1234## 4. setAttribute ---这个方法可以设置各种属性。不仅可以设置 css， // 1. 方法1 这种方法和 className用法没有区别 .oldClass{ color: red; } .newClass{ background-color: yellow; } hi xuxurusheng var div = document.querySelector('div'); div.onclick = function (){ // 这种方法文字颜色会为黑色 背景会变成黄色 this.setAttribute(\"class\", \"newClass\"); // 这种方法文字颜色不会为黑色，还是红色。 背景会变成黄色 this.setAttribute(\"class\", \"oldClass newClass\"); // 这两种方法都不会改变 style=\"width: 200px ;height: 200px; border: red 1px solid;\" 这一内嵌样式 } 12345678```//2. 可以通过 setAttribute 修改link里面的href 更改一个css文件，当然这个基本用不到&lt;link href=&quot;old.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; id=&quot;css&quot;/&gt; div.onclick = function (){ var css = document.getElementById(&quot;css&quot;); css.setAttribute(&quot;href&quot;,&quot;css2.css&quot;); }","link":"/2019/12/27/jsCss/"},{"title":"javascript浏览器存储机制","text":"1. 浏览器常见存储方案 cookie web存储 localstorage &amp; seesionStorage indexedDB2. cookie优点 兼容性好缺点 存储量小 4kb左右 影响性能 只能存储字符串 安全性问题 存储在cookie的人格数据可以被他人访问 有的用户可能把cookies禁用了1.使用 JavaScript 创建Cookie JavaScript 中，创建 cookie 如下所示： 1document.cookie=&quot;username=John Doe&quot;; 您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除： 1document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT&quot;; 您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。 1document.cookie=&quot;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;; 2.使用 JavaScript 读取 Cookie1var x = document.cookie; document.cookie 将以字符串的方式返回所有的 cookie，类型格式： cookie1=value; cookie2=value; cookie3=value; 3. 使用 JavaScript 修改 Cookie在 JavaScript 中，修改 cookie 类似于创建 cookie，如下所示： 1document.cookie=&quot;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/&quot;; 旧的 cookie 将被覆盖。 4. 使用 JavaScript 删除 Cookie删除 cookie 非常简单。您只需要设置 expires 参数为以前的时间即可，如下所示，设置为 Thu, 01 Jan 1970 00:00:00 GMT: 1document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;; 注意，当您删除时不必指定 cookie 的值。 3. localstorage存储读取数据 1234567method1 localStorage.setItem(&quot;keyName&quot;,&quot;keyValue&quot;); const name = localStorage.getItem(&quot;name);method2 localStorage.name = &quot;xuxurusheng&quot;; const name = localStorage.name 删除数据 1localStorage.removeItem(&quot;keyName&quot;);","link":"/2019/12/30/jsStorage/"},{"title":"javascript操作元素属性","text":"1. js获取元素属性 1. attributes 获取指定元素所有属性返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象 12345678910&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); console.log(obj.attributes); for (let i = 0; i &lt; obj.attributes.length; i++) { console.log(obj.attributes[i]); }&lt;/script&gt; 2.获取指定属性 element.属性只能获取内置属性值 123456789&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); console.log(obj.id); // 这里要使用 className 而不能使用class console.log(obj.className);&lt;/script&gt; 3. getAttribute不仅可以获取内置属性。还可以获取自定义属性值.自定义属性值用data-开头 12345678910&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 使用class就可以 不需要用classname console.log(obj.getAttribute('class')); // 还可以获取自定义属性值 console.log(obj.getAttribute('data-test'));&lt;/script&gt; 2. 修改属性 1. setAttribute用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。 element.setAttribute(&apos;属性名&apos;,&apos;属性值&apos;);1234567891011121314151617181920212223&lt;style&gt;.oldClass{ color: red;}.newClass{ background-color: yellow;}&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;oldClass&quot; style=&quot;width: 200px ;height: 200px; border: red 1px solid;&quot;&gt; hi xuxurusheng &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector('div'); div.onclick = function (){ // 这种方法文字颜色会为黑色 背景会变成黄色 this.setAttribute(&quot;class&quot;, &quot;newClass&quot;); // 这种方法文字颜色不会为黑色，还是红色。 背景会变成黄色 this.setAttribute(&quot;class&quot;, &quot;oldClass newClass&quot;); // 这两种方法都不会改变 style=&quot;width: 200px ;height: 200px; border: red 1px solid;&quot; 这一内嵌样式 }&lt;/script&gt; 2. dataset方法dataset实现的功能用setattribute都可以实现，速度比setattribute慢一点。自定义属性一般使用data- 开头 ，dataset是专门针对这种自定义属性的 获取 删除 创建123456789101112131415161718&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 当然 getAttribute 可以解决所有问题 console.log(obj.getAttribute('data-test')); // 针对data-开头 使用dataset只需要把 data-后面的属性写进去 obj.dataset.test=&quot;hello&quot;; console.log(obj.dataset.test); // 对于多个横杠连接的 data-foo-word 调用时需要使用驼峰命名 fooWord console.log(obj.dataset.fooWord); // 删除某一指定属性 delete obj.dataset.fooWord; // 创建一个属性原本没有的属性 obj.dataset.newCreat='ok'; console.log(obj.dataset.newCreat);&lt;/script&gt; 运行结果 data-foo-word被删除 data-new-creat 被创建 3. 移除属性 1. Element.removeAttribute()Element.removeAttribute方法用于从当前元素节点移除属性。 1234// &lt;div id=&quot;div1&quot; align=&quot;left&quot; width=&quot;200px&quot;&gt;document.getElementById('div1').removeAttribute('align');// 现在的HTML代码为// &lt;div id=&quot;div1&quot; width=&quot;200px&quot;&gt; 2. delet element.dataset.属性名删除一个自己创建的data-*属性，代码如上 4. 查询属性 hasAttribute() 方法返回一个布尔值，表示当前元素节点是否包含指定属性 123456789&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); if (obj.hasAttribute('data-test')) { console.log(obj.hasAttribute('data-test')); }&lt;/script&gt; 输出 ： true","link":"/2019/12/27/jsShuxing/"},{"title":"javascript闭包","text":"阮一峰：https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html","link":"/2020/01/01/jsclosure/"},{"title":"行内元素(内联元素)、块级元素、行内块级元素","text":"1. 行内元素 inline 12常见行内元素&lt;a&gt; &lt;span&gt; &lt;br&gt; &lt;i&gt; &lt;em&gt; &lt;strong&gt; &lt;label&gt; &lt;q&gt; &lt;var&gt; &lt;cite&gt; &lt;code&gt; 特点 不换行 高度、宽度、底部边距不可设置 高度就是包含文字后者图片的高度 2. 块级元素 block 12常见块级元素&lt;div&gt; &lt;p&gt; &lt;header&gt; &lt;ol&gt; &lt;ul&gt; &lt;Li&gt; &lt;dl&gt; &lt;table&gt; &lt;address&gt; &lt;blockquote&gt; &lt;from&gt; 特点 每个元素都从新的一行开始 元素高度宽度行高以及边距都可以设置 宽度不设置 默认 100% 3. 内联块元素 inline-block 1&lt;img&gt; &lt;input&gt; 特点 不换行 宽高行高边距可以设置","link":"/2020/01/02/blockInline/"},{"title":"Dom事件流","text":"1. 事件流 页面中接收事件的顺，事件发生时会在元素节点之间按照特定的顺序传播 捕获阶段 当前目标阶段 冒泡阶段 先捕获，后冒泡，捕获从上到下，冒泡从下到上 js代码只执行捕获或者冒泡的其中一个阶段 onclick 和 attachEvent 只能得到冒泡阶段 http://caibaojian.com/javascript-capture-bubble.html 总结结论： 对于一个节点，其父节点有捕获和冒泡 捕获限于冒泡 同一节点 有捕获有冒泡 按照js书写函数顺序进行","link":"/2019/12/28/jsDomEvent/"},{"title":"js鼠标事件汇总","text":"1. js鼠标事件汇总 onclick&amp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当用户点击某个对象时调用的事件句柄。 oncontextmenu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在用户点击鼠标右键打开上下文菜单时触发 ondblclick &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户双击某个对象时调用的事件句柄。 onmousedown &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标按钮被按下。 onmouseenter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当鼠标指针移动到元素上时触发。 onmouseleave &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当鼠标指针移出元素时触发 onmousemove &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标被移动。 onmouseover &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标移到某元素之上。 onmouseout &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标从某元素移开。 onmouseup &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标按键被松开。 2. 事件触发事件源+事件类型+事件处理程序 12345var shijianyuan = document.getElementById('tijiao'); // 事件源shijianyuan.onclick = function(event){ // onclick 为事件触发类型 // function 内为事件触发函数} 3. 触发时的参数event为MouseEvent对象类型： type &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件类型，如’mosemove’或者’mousedown’ button&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整型，触发鼠标事件时按下的按钮编号 buttons&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整型，触发鼠标事件时弹起来的按钮编号 [x]clientX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在DOM内容区的X坐标 [x]X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上 [x]clientY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在DOM内容区的Y坐标 [x]Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上 [x]offsetX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针相对父节点填充边缘的X坐标 [x]offsetY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标指针相对父节点填充边缘的Y坐标 [x]screenX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在全局屏幕的X坐标 [x]screenY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在全局屏幕的Y坐标 [x]pageX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在整个DOM内容（包括分页）的X坐标 [x]pageY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在整个DOM内容（包括分页）的Y坐标 [x]altKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的alt键和鼠标是否同时按下 [x]ctrKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的alt键和鼠标是否同时按下 [x]shiftKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的shift键是和鼠标是否同时按下 [x]metaKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，windows平台表示Window键是否同时按下，mac表示Command键是否同时按下 12345678910# 示例程序返回点击时鼠标的坐标&lt;body&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log(MouseEvent.x); } &lt;/script&gt;&lt;/body&gt; 4. mouseover &amp; mouseenter（mouseleave） 区别- mouseover 和 mouseenter 都是移动到元素上就会出发事件（mouseleave是移出） - mouseover 经过自己的盒子和子盒子都会触发 - mouseenter 只有经过自身盒子会触发 因为 mouseenter（mouseleave）不会冒泡","link":"/2019/12/26/mouse/"},{"title":"mysql常见问题及解决方案","text":"忘记密码、设置初始密码 用命令编辑/etc/my.cnf配置文件 1vi /etc/my.cnf [mysqld]下添加skip-grant-tables，然后保存并退出 1skip-grant-tables 重启mysql服务 1service mysqld restart 进入服务器直接就可以登录不需要密码 1mysql 修改密码,刷新权限，退出 123UPDATE mysql.user SET Password=PASSWORD('新密码') where USER='root';flush privileges;exit 删除掉刚才添加的 skip-grant-tables 用新密码登录即可 1mysql -u root -p 引用：https://www.linuxidc.com/Linux/2018-05/152586.htm","link":"/2019/12/26/mysqlQuestions/"},{"title":"flex布局","text":"整理自：https://zhuanlan.zhihu.com/p/25303493 1. Flex 容器： 首先，实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。 123.container { display: flex | inline-flex; //可以有两种取值} 2. flex容器属性 1. flex-direction: 决定主轴的方向(即项目的排列方向).container { flex-direction: row | row-reverse | column | column-reverse;} row 主轴为水平方向，起点在左端。 （默认） row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 2. flex-wrap: 决定容器内项目是否可换行(或者换列)123.container { flex-wrap: nowrap | wrap | wrap-reverse;} nowrap 不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。(default) wrap：项目主轴总尺寸超出容器时换行，第一行在上方 wrap-reverse：换行，第一行在下方 3. flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性。1234 flex-wrap: wrap; flex-direction: row;= flex-flow: row wrap; 4. justify-content：定义了项目在主轴的对齐方式。123.container { justify-content: flex-start | flex-end | center | space-between | space-around;} flex-start 左对齐(default) flex-end 右对齐 center：居中 space-between：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙。 space-around：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。 5. align-items: 定义了项目在交叉轴上的对齐方式 （ flex-direction: row 时 垂直方向的对齐方式） stretch 即如果项目未设置高度或者设为 auto，将占满整个容器的高度。（默认）假设容器高度设置为 100px，而项目都没有设置高度的情况下，则项目的高度也为 100px。 flex-start：交叉轴的起点对齐（上对齐） flex-end：交叉轴的终点对齐（底对齐） center：交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐 flex item 属性 order flex-basis flex-grow flex-shrink flex align-self 1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0123.item { order: &lt;integer&gt;;} 2. flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间123.item { flex-basis: &lt;length&gt; | auto;} 默认值：auto，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。 当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。 当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。 当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。3. flex-grow: 定义项目的放大比例 123.item { flex-grow: &lt;number&gt;;} 默认值为 0，即如果存在剩余空间，也不放大当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话) 如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。 4. flex-shrink 定义了项目的缩小比例123.item { flex-shrink: &lt;number&gt;;} 默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 5. flex: flex-grow, flex-shrink 和 flex-basis的简写 flex-grow 默认值为 0 flex-shrink 默认值为 1 flex-basis 默认为 auto 区别 当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大） 当 flex-wrap 为 wrap | wrap-reverse，且子项宽度和超过父容器宽度时，首先一定会换行，换行后，每一行的右端都可能会有剩余空间（最后一行包含的子项可能比前几行少，所以剩余空间可能会更大），这时 flex-grow 会起作用，若当前行所有子项的 flex-grow 都为0，则剩余空间保留，若当前行存在一个子项的 flex-grow 不为0，则剩余空间会被 flex-grow 不为0的子项占据 当 flex-wrap 为 nowrap，且子项宽度和不及父容器宽度时，flex-grow 会起作用，子项会根据 flex-grow 设定的值放大（为0的项不放大） 当 flex-wrap 为 nowrap，且子项宽度和超过父容器宽度时，flex-shrink 会起作用，子项会根据 flex-shrink 设定的值进行缩小（为0的项不缩小）。但这里有一个较为特殊情况，就是当这一行所有子项 flex-shrink 都为0时，也就是说所有的子项都不能缩小，就会出现讨厌的横向滚动条 总结上面四点，可以看出不管在什么情况下，在同一时间，flex-shrink 和 flex-grow 只有一个能起作用，这其中的道理细想起来也很浅显：空间足够时，flex-grow 就有发挥的余地，而空间不足时，flex-shrink 就能起作用。当然，flex-wrap 的值为 wrap | wrap-reverse 时，表明可以换行，既然可以换行，一般情况下空间就总是足够的，flex-shrink 当然就不会起作用 6. align-self: 允许单个项目有与其他项目不一样的对齐方式123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;}","link":"/2019/12/30/flexLayout/"},{"title":"centos7.x 安装nodeJs","text":"1.安装gcc，make，openssl，wget1yum install -y gcc make gcc-c++ openssl-devel wget 2.下载源代码包 官方地址：https://nodejs.org/en/download/ 1wget https://nodejs.org/dist/v9.3.0/node-v9.3.0.tar.gz 3.解压源代码包1tar -xf node-v9.3.0.tar.gz 4.编译进入源代码所在路径1cd node-v9.3.0 执行配置脚本1./configure 编译与部署1make &amp;&amp; make install 接着就是等待编译完成… 5.测试node版本号1node -v npm版本号1npm -v ==作者 ：XCC ==","link":"/2019/12/26/nodeJs2/"},{"title":"树莓派使用基础教程（1）系统安装及远程登陆","text":"系统安装 树莓派提供了系统安装工具NOOBS 1. 进入下载页面 左侧是 图形化界面的系统、右侧是不带图形化界面的系统，没什么区别 https://www.raspberrypi.org/downloads/ 我们选右边这个，高级一点 2. 选择一种方式下载（迅雷好像快一点） 网盘我也存了一份：https://pan.baidu.com/s/1QFVUocKJpe1QmxssRWuRHg 3. 解压 解压下来是这个样子，目录不要含有中文，不然做系统盘会出错 4. 格式化sd卡，格式化成FAT 感觉格式化完内存显示有问题用磁盘管理工具重新分一下区然后重新格式化 5. 下载系统写入工具 推荐使用 diskimage，扔个CDN加速的下载链接给你：http://files.qianduan.ltd/win32diskimager-1.0.0-install.exe 6. 写入系统文件 7. emmm快成功了通过ssh链接1. 在boot目录下写入 SSH文件2. 在根目录下新建```12 country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={ ssid=”WiFi-A” psk=”12345678” key_mgmt=WPA-PSK priority=1} 12345678910111213141516171819202122&gt; #ssid:网络的ssid&gt; #psk:密码&gt; #priority:连接优先级，数字越大优先级越高（不可以是负数）&gt; #scan_ssid:连接隐藏WiFi时需要指定该值为1&gt; #key_mgmt:加密方式 （进路由器后台看）&gt;&gt; ``` key_mgmt=WPA-PSK ``` :使用WPA/WPA2加密(一般都是这个)&gt;&gt; ``` key_mgmt=NONE ``` ：WEP加密![image](http://image.qianduan.ltd/s10.png)#### 3. 把sd卡安装至卡槽，上电启动#### 4. 查看树莓派IP &gt; 1. 可以通过路由器后台查看![image](http://image.qianduan.ltd/s5.png)&gt; 2. 用命令ping一下``` ping -4 raspberrypi 默认ping出的是IPV6，所以加个 -4 强制转换一下 5. 下载个远程登陆工具 xshell （相对较专业）和 putty（开源轻便） 选一个：https://qdzy.xccstu.top/qdzy/site/yzrj.html 6. 登录 输入刚才ping到的IP 默认用户名：pi 默认密码：raspberry","link":"/2019/12/25/rpiPre1/"},{"title":"树莓派使用基础教程（3）文件操作","text":"1. 操作文件 主要针对文本文件 文件常用命令 (python) 查询当前目录文件 123&gt;&gt;&gt; os.listdir()['test2.py', 'test1.py', 'test3.py']&gt;&gt;&gt; 创建文件 1234&gt;&gt;&gt; import os&gt;&gt;&gt; filename=&quot;test4.py&quot;&gt;&gt;&gt; os.mknod(filename)&gt;&gt;&gt; 修改文件名 12&gt;&gt;&gt; os.rename(&quot;test4.py&quot;,&quot;test5.py&quot;)&gt;&gt;&gt; 删除文件 12&gt;&gt;&gt; os.remove(&quot;test5.py&quot;)&gt;&gt;&gt; 打开文件 1&gt;&gt;&gt; test=open(&quot;test.txt&quot;) 写入文件 123456789101112131415&gt;&gt;&gt; test=open(&quot;test.txt&quot;) # 打开文件&gt;&gt;&gt; testnum=10 #定义写入变量&gt;&gt;&gt; test.write(testnum) #写入函数 openTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: write() argument must be str, not int # 报错，写入文件类型只能是数字&gt;&gt;&gt; teststring=&quot;123456&quot; # 写一个字符串重新写入&gt;&gt;&gt; test.write(teststring)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;io.UnsupportedOperation: not writable #再次报错，文件只读 &gt;&gt;&gt; test=open(&quot;test.txt&quot;,&quot;w&quot;) #重新打开文件，mode写成 “w” “a”不会擦除 可写。但是w会移除原有内容&gt;&gt;&gt; test.write(teststring)6&gt;&gt;&gt; 读取文件 1234567&gt;&gt;&gt; testread=open(&quot;test.txt&quot;,&quot;r&quot;)&gt;&gt;&gt; test_data=testread()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '_io.TextIOWrapper' object is not callable&gt;&gt;&gt; test_data=testread.read()&gt;&gt;&gt; print(test_data) 2. 函数 定义函数 1234def funcname(): statement1 #参数 statement2 return value #返回值 调用函数1funcname() 设定参数默认值1def funcname(width,height=20): 3. 模块 列出一个模块所有函数1234&gt;&gt;&gt; import os &gt;&gt;&gt; dir(os) #列出所有函数['CLD_CONTINUED', 'CLD_DUMPED', 'CLD_EXITED', 'CLD_TRAPPED', 'DirEntry', 'EX_CANTCREAT', 'EX_CONFIG', 'EX_DATAERR', 'EX_IOERR', 'EX_NOHOST', 'EX_NOINPUT', 'EX_NOPERM', 'EX_NOUSER', 'EX_OK', 'EX_OSERR', 'EX_OSFILE', 'EX_PROTOCOL', 'EX_SOFTWARE', 'EX_TEMPFAIL', 'EX_UNAVAILABLE', 'EX_USAGE', 'F_LOCK', 'F_OK', 'F_TEST', 'F_TLOCK', 'F_ULOCK', 'GRND_NONBLOCK', 'GRND_RANDOM', 'MutableMapping', 'NGROUPS_MAX', 'O_ACCMODE', 'O_APPEND', 'O_ASYNC', 'O_CLOEXEC', 'O_CREAT', 'O_DIRECT', 'O_DIRECTORY', 'O_DSYNC', 'O_EXCL', 'O_LARGEFILE', 'O_NDELAY', 'O_NOATIME', 'O_NOCTTY', 'O_NOFOLLOW', 'O_NONBLOCK', 'O_PATH', 'O_RDONLY', 'O_RDWR', 'O_RSYNC', 'O_SYNC', 'O_TMPFILE', 'O_TRUNC', 'O_WRONLY', 'POSIX_FADV_DONTNEED', 'POSIX_FADV_NOREUSE', 'POSIX_FADV_NORMAL', 'POSIX_FADV_RANDOM', 'POSIX_FADV_SEQUENTIAL', 'POSIX_FADV_WILLNEED', 'PRIO_PGRP', 'PRIO_PROCESS', 'PRIO_USER', 'P_ALL', 'P_NOWAIT', 'P_NOWAITO', 'P_PGID', 'P_PID', 'P_WAIT', 'PathLike', 'RTLD_DEEPBIND', 'RTLD_GLOBAL', 'RTLD_LAZY', 'RTLD_LOCAL', 'RTLD_NODELETE', 'RTLD_NOLOAD', 'RTLD_NOW', 'RWF_DSYNC', 'RWF_HIPRI', 'RWF_NOWAIT', 'RWF_SYNC', 'R_OK', 'SCHED_BATCH', 'SCHED_FIFO', 'SCHED_IDLE', 'SCHED_OTHER', 'SCHED_RESET_ON_FORK', 'SCHED_RR', 'SEEK_CUR', 'SEEK_DATA', 'SEEK_END', 'SEEK_HOLE', 'SEEK_SET', 'ST_APPEND', 'ST_MANDLOCK', 'ST_NOATIME', 'ST_NODEV', 'ST_NODIRATIME', 'ST_NOEXEC', 'ST_NOSUID', 'ST_RDONLY', 'ST_RELATIME', 'ST_SYNCHRONOUS', 'ST_WRITE', 'TMP_MAX', 'WCONTINUED', 'WCOREDUMP', 'WEXITED', 'WEXITSTATUS', 'WIFCONTINUED', 'WIFEXITED', 'WIFSIGNALED', 'WIFSTOPPED', 'WNOHANG', 'WNOWAIT', 'WSTOPPED', 'WSTOPSIG', 'WTERMSIG', 'WUNTRACED', 'W_OK', 'XATTR_CREATE', 'XATTR_REPLACE', 'XATTR_SIZE_MAX', 'X_OK', '_Environ', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_execvpe', '_exists', '_exit', '_fspath', '_fwalk', '_get_exports_list', '_putenv', '_spawnvef', '_unsetenv', '_wrap_close', 'abc', 'abort', 'access', 'altsep', 'chdir', 'chmod', 'chown', 'chroot', 'close', 'closerange', 'confstr', 'confstr_names', 'cpu_count', 'ctermid', 'curdir', 'defpath', 'device_encoding', 'devnull', 'dup', 'dup2', 'environ', 'environb', 'error', 'execl', 'execle', 'execlp', 'execlpe', 'execv', 'execve', 'execvp', 'execvpe', 'extsep', 'fchdir', 'fchmod', 'fchown', 'fdatasync', 'fdopen', 'fork', 'forkpty', 'fpathconf', 'fsdecode', 'fsencode', 'fspath', 'fstat', 'fstatvfs', 'fsync', 'ftruncate', 'fwalk', 'get_blocking', 'get_exec_path', 'get_inheritable', 'get_terminal_size', 'getcwd', 'getcwdb', 'getegid', 'getenv', 'getenvb', 'geteuid', 'getgid', 'getgrouplist', 'getgroups', 'getloadavg', 'getlogin', 'getpgid', 'getpgrp', 'getpid', 'getppid', 'getpriority', 'getrandom', 'getresgid', 'getresuid', 'getsid', 'getuid', 'getxattr', 'initgroups', 'isatty', 'kill', 'killpg', 'lchown', 'linesep', 'link', 'listdir', 'listxattr', 'lockf', 'lseek', 'lstat', 'major', 'makedev', 'makedirs', 'minor', 'mkdir', 'mkfifo', 'mknod', 'name', 'nice', 'open', 'openpty', 'pardir', 'path', 'pathconf', 'pathconf_names', 'pathsep', 'pipe', 'pipe2', 'popen', 'posix_fadvise', 'posix_fallocate', 'pread', 'preadv', 'putenv', 'pwrite', 'pwritev', 'read', 'readlink', 'readv', 'register_at_fork', 'remove', 'removedirs', 'removexattr', 'rename', 'renames', 'replace', 'rmdir', 'scandir', 'sched_get_priority_max', 'sched_get_priority_min', 'sched_getaffinity', 'sched_getparam', 'sched_getscheduler', 'sched_param', 'sched_rr_get_interval', 'sched_setaffinity', 'sched_setparam', 'sched_setscheduler', 'sched_yield', 'sendfile', 'sep', 'set_blocking', 'set_inheritable', 'setegid', 'seteuid', 'setgid', 'setgroups', 'setpgid', 'setpgrp', 'setpriority', 'setregid', 'setresgid', 'setresuid', 'setreuid', 'setsid', 'setuid', 'setxattr', 'spawnl', 'spawnle', 'spawnlp', 'spawnlpe', 'spawnv', 'spawnve', 'spawnvp', 'spawnvpe', 'st', 'stat', 'stat_result', 'statvfs', 'statvfs_result', 'strerror', 'supports_bytes_environ', 'supports_dir_fd', 'supports_effective_ids', 'supports_fd', 'supports_follow_symlinks', 'symlink', 'sync', 'sys', 'sysconf', 'sysconf_names', 'system', 'tcgetpgrp', 'tcsetpgrp', 'terminal_size', 'times', 'times_result', 'truncate', 'ttyname', 'umask', 'uname', 'uname_result', 'unlink', 'unsetenv', 'urandom', 'utime', 'wait', 'wait3', 'wait4', 'waitid', 'waitid_result', 'waitpid', 'walk', 'write', 'writev']&gt;&gt;&gt; 查询帮助信息12help(os.CLD_DUMPED)q # 退出","link":"/2019/12/25/rpiPre3/"},{"title":"树莓派使用基础教程（2）系统安装及远程登陆","text":"1. 查询raspberrypi自带python版本 python2版本 2.7.16（默认使用） python3版本 3.7.3 退出python ：CTRL+D 2. 添加注释1# 3. 变量 区分大小写 ==实际没有变量实际是对变量对象的引用== 避免变量名与关键字重复 123456789# 查看关键字pi@raspberrypi:~/code $ python3Python 3.7.3 (default, Apr 3 2019, 05:39:12) [GCC 8.2.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import keyword&gt;&gt;&gt; print(keyword.kwlist)['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']&gt;&gt;&gt; 变量名第一个字符只能是字母和下划线 长（多）字符串赋值 查询变量类型 1type(变量名) 4. 运算 普通运算和别的语言一样特殊运算1. 分数对象 ==Fraction==12from fractions import Fraction #引入模块创建对象test = Fraction(分子,分母) #创建的分数对象可以进行数字运算 实例 12345&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt; test=Fraction(2,6)&gt;&gt;&gt; print(test)1/3&gt;&gt;&gt; 2. 复数操作 3. math模块 和别的函数的math对象基本相同https://blog.csdn.net/iamaiearner/article/details/9381347整体引入 12import math #引入模块math.funcname() #调用 单个引入 12from math import funcname # 引入单个模块funcname( ) # 直接调用 4. 数组处理 NumPy模块1import numpy 5. 控制语句 没什么特别的 强依赖缩进+冒号 1234if: print()else: print() 6. 循环语句 语法结构和js相似， 强依赖缩进+冒号 12345# for in 循环for the_number in [1,2,3,4,5]:### . 常用命令#### 1. print() python3 print(argument) 12345678910- 字符&gt; 单引号或者双引号&gt; 三重引号实现带格式输出 (使用转义符\\n效果一样)![image](http://image.qianduan.ltd/po1.png)&gt; 代码``` print(&quot;&quot;&quot; 第一行 第二行 第三行&quot;&quot;&quot;) 输出 12345pi@raspberrypi:~/code $ python3 test3.py 第一行 第二行 第三行","link":"/2019/12/25/rpiPre2/"},{"title":"树莓派使用基础教程（4）自定义模块调用","text":"先创建一个自定义模块 123# libtest.pydef AaaB(): print(&quot;happy~&quot;) 库文件调用1. 同目录调用 test5.py libtest.py 123# test5.py codeimport libtest # 引入模块文件libtest.AaaB() # 运行相应函数 2. 不同目录下调用 为了不让文件过于混乱，通常新建一个lib的文件夹，即目录以如下方式呈现 test5.py lib libtest.py 12345# test5.py codeimport syssys.path.append(&quot;/home/pi/code/lib&quot;) # 绝对目录import libtestlibtest.AaaB()","link":"/2019/12/25/rpiPre4/"},{"title":"树莓派实战（1）：点亮小灯","text":"就像学习哦计算机语言第一步往往是输出一个 hello world一样，玩板子第一步一定是点个灯 程序12345import RPi.GPIO as GPIOGPIO.setmode(GPIO.BOARD)GPIO.setup(7,GPIO.OUT)while True: GPIO.output(7,GPIO.HIGH) 知识点树莓派使用的是GPIO的模块用来控制引脚，所谓GPIO也就是==general-purpose input/output==通用输入输出接口123# 1. 引入 GPIO模块import RPi.GPIO as GPIO GPIO控制引脚的编码方式主要有三种 按照插座编号编码 （==header==） BCM编号方式(==BCM GPIO==) wiringPi编号方式 (==wiringPi==) 一般采用第一种或者第二种那个习惯用哪个，第三种主要注重逻辑，可以但没必要。 12345# 编号方式设定GPIO.setmode(GPIO.BOARD) #第一种GPIO.setmode(GPIO.BCM) # 第二种 设置通道工作方式123#用作输入GPIO.setup(channel, GPIO.IN) 1234#用作输出GPIO.setup(channel, GPIO.OUT) GPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH) #为引脚设置默认值 设置通道的逻辑值123456# 输入通道GPIO.input(channel) #读取通过的逻辑值，比如按键事件# 返回0 / GPIO.LOW / False or 1 / GPIO.HIGH / True. 1234567891011121314#输出通道GPIO.output(channel, state)# statue：GPIO.HIGH / GPIO.LOW也可以同时设置多个通道输出chan_list = [11,12] GPIO.output(chan_list, GPIO.LOW) GPIO.output(chan_list, (GPIO.HIGH, GPIO.LOW))# 第一个11是高电平、12是低电平 清空引脚1GPIO.cleanup()","link":"/2019/12/25/rpiUse1/"},{"title":"centos7.x安装mongodb","text":"安装教程1:创建仓库1vi /etc/yum.repos.d/mongodb-org-3.4.repo 2：把下面的内容复制到文件中 保存退出123456[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc 3：yum安装1yum install -y mongodb-org 4：启动mogodb123systemctl start mongod.service //启动systemctl stop mongod.service //停止systemctl restart mongod.service //重启 5:设置开机自启动1systemctl enable mongod 6：链接mongodb1mongo 127.0.0.1:27017 7.如需修改配置文件（安装时不需修改）1vi /etc/mongod.conf 8.安装完成之后各种默认路径 MongoDB默认将数据文件存储在/var/lib/mongo目录 默认日志文件在/var/log/mongodb中如果要修改,可以在 /etc/mongod.conf 配置中指定备用日志和数据文件目录 MongoDB默认将数据文件存放在/var/lib/momgo目录 , 默认日志文件存在/var/log/mongodb/mongod.log目录, 如需修改可以在/etc/mongod.conf配置文件中指定目录 解决方法1.异常关闭重启服务器后连接失败解决方法mongod.lock文件 在mongodb的启动时，在数据目录下，会生成一个==mongod.lock==文件。mongod.lock文件存放的是启动mongod的进程号.如果在正常退出时，会清除这个mongod.lock文件，若要是异常退出，在下次启动的时候，会禁止启动，从而保留一份干净的一份副本数据。所以我们可以手动删除文件来解决这个问题 mongod.lock 一般是存储在数据文件目录下的,如果按照本文件安装mongodb，则路径是 ==/var/lib/mongo== 123/var/lib/mongo //进入数据目录ls -sh //查看此目录下所有文件 1rm mongod.lock 删除mongod.lock文件","link":"/2019/12/26/mongodbQuestions1/"},{"title":"树莓派实战（2）让小灯bling~bling~","text":"程序123456789import RPi.GPIO as GPIOimport time #引用time模块GPIO.setmode(GPIO.BOARD)GPIO.setup(7,GPIO.OUT)while True: GPIO.output(7,GPIO.HIGH) time.sleep(0.1) # 延时0.1秒 GPIO.output(7,GPIO.LOW) time.sleep(0.1) 知识点 相对于让小灯亮，让丫blingbling的亮只是多了个延时程序 引用 time 模块1import time time的功能还是很多的，但是在pi里面用到的（入门使用）不是太多，当然等玩的好了写个后台什么的会经常用到,我们暂且讨论两个 ==sleep== 和 ==clock== time.sleep(sec) 推迟调用线程的运行,实现程序的延时 1234import timeprint(&quot;开始&quot;)time.sleep(5)print(&quot;5秒后结束&quot;) 12345# 运行结果pi@raspberrypi:~/code $ python3 test3.py开始5秒后结束pi@raspberrypi:~/code $ time.clock() 就是经常将的时间戳，知道这玩意可以用来记录一段时间（比如程序运行的时间）就行 123# python 3.8以后会被禁用，可以换成 time.process_time pi@raspberrypi:~/code $ python3 test3.pytest3.py:2: DeprecationWarning: time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead 123456#实例程序import timetime1=time.process_time() # 返回第一个时间time.sleep(5)time2=time.process_time() # 中间那段程序跑完返回第二个时间print(time2-time1) #做差就是间隔时间 1234#运行结果pi@raspberrypi:~/code $ python3 test3.py5.557400000000268e-05pi@raspberrypi:~/code $","link":"/2019/12/25/rpiUse2/"},{"title":"树莓派实战（3）按键控制小灯","text":"程序12345678910import RPi.GPIO as GPIO GPIO.setmode(GPIO.BOARD) #引脚编码方式GPIO.setup(7,GPIO.OUT,initial=GPIO.LOW) # 小灯，7号引脚，默认不亮,输出GPIO.setup(11,GPIO.IN) # 按键读取while True: statue=GPIO.input(11) # 读取按键是否被按下 if statue==1: GPIO.output(7, GPIO.HIGH) else: GPIO.output(7, GPIO.LOW) 接线图 知识点 程序控制语句 if else注意书写格式就行","link":"/2019/12/25/rpiUse3/"},{"title":"vscode使用技巧","text":"设置多个光标在多处编辑1. alt+鼠标左键 可以多次点击设置多个光标2. ctrl+alt+键盘上下键 可以在当前位置上下3. 用鼠标选中一块区域 shift+alt+i 可以在这一个区域每一行的行末出现光标4. Ctrl + U 取消这些操作同时选中一篇代码所有相同字符串1. 用鼠标选中一个字符串 ctrl+shift+L 可以在全篇选取2. ctrl+h","link":"/2019/12/27/vscodeSkills/"},{"title":"the difference between let & var jn javascript","text":"1. 阮一峰：http://es6.ruanyifeng.com/#docs/let let 只在let命令所在代码块内有效 let不存在变量提升 var会发生变量提升，值为 undefined 暂时性死区 只要内部有let 里面的变量就不会受外部影响12345678var tmp = 123;if (true) { &lt;!-- 因为内部有let重新声明了变量 所以就绑定了这个区域 tmp就不再受外部影响 所以给tmp复制会referenceError--&gt; tmp = 'abc'; // ReferenceError let tmp;}** ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。** typeof变得不是100%安全，之前计师是没有定义的变量名，typeof也不会报错，但是出现在死区里的时候 typeof可能会报错 ReferenceError1234567{ typeof x; // ReferenceError let x;}{ typeof x ; // undefined} 关于 TDZ 123456789function bar(x = y, y = 2) { return [x, y];}bar(); // 报错上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。function bar(x = 2, y = x) { return [x, y];}bar(); // [2, 2] 1234567// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 let 不允许在相同作用域内 重复声明同一变量 const 和 let相似 只是const只读，赋值会报错 ，所以声明时就应该赋值，const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 老马 ：https://www.cnblogs.com/fly_dragon/p/8669057.html","link":"/2020/01/01/letVarJs/"},{"title":"微信小程序全局传参","text":"//app.js中, 123globalData: { data:lala } //a.js中 123456const app = getApp();Page({ onLoad: function (options){ let data = app.globalData.data;}})","link":"/2019/12/31/wxCanshu/"},{"title":"offset、 screen、 client 、 page的区别","text":"1. offsetY 、 screenY 、 clientY (y) 、 pageY的区别 12345678910111213141516&lt;body style=&quot;height: 2000px;&quot;&gt; &lt;html&gt; &lt;div style=&quot;width: 500px; height: 500px; background-color: aqua; margin: 200px auto auto 200px; padding: 100px;&quot;&gt; &lt;div style=&quot;width: 200px; height: 200px; background-color: brown;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/html&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log('clienty的坐标是'+MouseEvent.y); console.log('pagey的坐标是'+MouseEvent.pageY); console.log('offsety的坐标是'+MouseEvent.offsetY); console.log('screeny的坐标是'+MouseEvent.screenY); } &lt;/script&gt;&lt;/body&gt; 运行结果 offsetY相对于带有定位的父节点的位置而言 screenY相对于整个显示器的位置而言 clientY相对于当前页面的位置而言 scrollY相对于当前页面+纵向滚动距离（）的位置而言 2.总结http://sineava.top/cate/javascript/page/Dom%E4%B8%8EBom.html#js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6","link":"/2019/12/30/scrollPageClient/"},{"title":"软件著作权申请指南","text":"记得当年第一次申请软件著作权，踩了很多坑，补了2次材料，拖了3个月才拿到手，今天又有东西需要提交来写一篇文档吧。 用户注册、线上申请网址 http://www.ccopyright.com.cn/==仅支持IE、360浏览器，并且打开兼容模式。firefox，chrome都不行== 申请步骤 官方文档： http://www.ccopyright.com.cn/index.php?optionid=1057 1. 阅读相关文件 文件汇总 http://www.ccopyright.com.cn/index.php?optionid=1003 2. 在线填报 填报模板范文：http://files.qianduan.ltd/muban.pdf 官方填报说明文档：http://www.ccopyright.com.cn/index.php?optionid=1081 3. 申请表打印、签字 打印下来的软件著作权申请表一定要确保两个事情 每一页申请表的最上面都应该有 页码、流水号,如果没有请把版权保护中心网站添加到兼容网站 申请人签字 4. 文件准备 官方说明文件 http://www.ccopyright.com.cn/index.php?optionid=1080 打印下来的 申请表(签章) 软件鉴别材料：软件源程序、文档 申请人若在源程序和文档页眉上标注了所申请软件的名称和版本号，应当与申请表中相应内容完全一致，==右上角应标注页码，源程序每页不少于50行==，最后一页应是程序的结束页，文档每页不少于30行，有图除外。如果源程序小于60页，请全部提交。大于60页提交前后30页。大概是这个样子： 身份证明材料营业执照、身份证。。。。。。。。（详见官方说明）。保证每个著作权人都有一个证明文件在上面 大于等于2个著作权人需要合作开发协议。给大家一个我自己写的模板 下载地址： http://files.qianduan.ltd/fb.docx 其他还有一些特殊需求的请仔细研读官方文档 最后大家提交申请材料清单的顺序填写并整理整齐、切勿装订。怕掉可以用个小夹子 5. 邮寄 地址：北京市西城区天桥南大街1号天桥艺术大厦A座三层302（邮编：100050）010-68003887 包裹上备注一下：软件登记部 6. 收证书版权保住中心邮寄的是邮政的挂号信，一般在制证10天附件就能收到，收不到自己去联系附近的邮政单位 7. 关于版权保护中心服务问题 大家在办理过程中可能发现基本打不通客服电话，请大家予以谅解。随着软件著作权申请的免费，工作人员每天需要处理大量文件，而且证书费、邮寄证书的快递费都不需要我们付费。体谅工作人员，即使查收邮件。希望大家申请顺利。","link":"/2019/12/26/ruanzhu/"},{"title":"浏览器内核","text":"1. 浏览器内核（理解） 浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 （1）Trident(IE内核)国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 （2）Gecko(firefox)Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 （3） webkit(Safari) Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器， （4） Chromium/Bink(chrome) 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。 ​ 大部分国产浏览器最新版都采用Blink内核。 （5） Presto(Opera) Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。 了解一点：移动端的浏览器内核主要说的是系统内置浏览器的内核。目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。","link":"/2019/12/30/neihe/"},{"title":"安医大评教系统快速选择方法","text":"兄弟，这样的评教系统看着崩不崩溃？？？ 解放双手教程： 浏览器支持情况:(使用教务系统1) 已支持 chrome 已支持 opera 浏览器 已支持 edge 但是需要修改一点 已支持 360极速浏览器 已支持 搜狗浏览器 已支持 qq浏览器 已支持 firefox火狐浏览器 IE 算了吧 360安全浏览器用的是本地IE的内核，就是换了个皮肤 也算了吧 1. 视频教程code： 123456789var selectBox = document.querySelectorAll('select');for(var i = 0 ; i &lt; selectBox.length ; i ++){ selectBox[i].value='A'}var teachNum = Math.round((selectBox.length-1)/10);for(let j = 0 ; j &lt; teachNum ; j++){ var selectB = Math.floor(Math.random()*10)*teachNum+(j+1); selectBox[selectB].value='B'; } 1.1 chrome （推荐使用，https://www.google.cn/chrome/） 视频加载不出来点这个： 点我点我 1.2 edge edge改一下框架 ↓↓↓ 视频加载不出来点这个：点我点我 1.3 360极速浏览器 360极速浏览器需要修改一下内核，换成chrome的内核：↓ ↓ ↓ 视频加载不出来点这个：点我点我 1.4 火狐浏览器 视频加载不出来点这个：点我点我 火狐的代码略有不同： 12345678910cd(window.frames[0])var selectBox = document.querySelectorAll('select');for(var i = 0 ; i &lt; selectBox.length ; i ++){ selectBox[i].value='A'}var teachNum = Math.round((selectBox.length-1)/10);for(let j = 0 ; j &lt; teachNum ; j++){ var selectB = Math.floor(Math.random()*10)*teachNum+(j+1); selectBox[selectB].value='B'; } 1.5 其他浏览器基本没啥个性 文字说明1. 进入评教页面，点击鼠标右键，选择 “检查” 进入控制台 - 不知道自己的浏览器怎么进入控制台点下方 Document function getExplore(){ var Sys = {}; var ua = navigator.userAgent.toLowerCase(); var s; (s = ua.match(/rv:([\\d.]+)\\) like gecko/)) ? Sys.ie = s[1] : (s = ua.match(/msie ([\\d\\.]+)/)) ? Sys.ie = s[1] : (s = ua.match(/edge\\/([\\d\\.]+)/)) ? Sys.edge = s[1] : (s = ua.match(/firefox\\/([\\d\\.]+)/)) ? Sys.firefox = s[1] : (s = ua.match(/(?:opera|opr).([\\d\\.]+)/)) ? Sys.opera = s[1] : (s = ua.match(/chrome\\/([\\d\\.]+)/)) ? Sys.chrome = s[1] : (s = ua.match(/version\\/([\\d\\.]+).*safari/)) ? Sys.safari = s[1] : 0; // 根据关系进行判断 if (Sys.ie) window.open(\"http://www.baidu.com/s?wd=IE浏览器怎么打开控制台\") ; if (Sys.edge) window.open(\"http://www.baidu.com/s?wd=edge浏览器怎么打开控制台\") ; if (Sys.firefox) window.open(\"http://www.baidu.com/s?wd=firefox浏览器怎么打开控制台\") ; if (Sys.chrome) window.open(\"http://www.baidu.com/s?wd=chrome浏览器怎么打开控制台\") ; if (Sys.opera) window.open(\"http://www.baidu.com/s?wd=opera浏览器怎么打开控制台\") ; if (Sys.safari) window.open(\"http://www.baidu.com/s?wd=safari浏览器怎么打开控制台\") ; } 我的浏览器怎么打开控制台(点我点我) 2.点击控制台左上角的小箭头，随便选中一个评价框 3.把下面这个代码黏贴到下面这个框框里（框框里有报错也没事，直接贴到框框最后）,然后按回车 123456789var selectBox = document.querySelectorAll('select');for(var i = 0 ; i &lt; selectBox.length ; i ++){ selectBox[i].value='A'}var teachNum = Math.round((selectBox.length-1)/10);for(let j = 0 ; j &lt; teachNum ; j++){ var selectB = Math.floor(Math.random()*10)*teachNum+(j+1); selectBox[selectB].value='B'; } 4. 这样应该就选好了，选的策略是一个老师一个B其他都是A,如果提示有全选A的，请手动修改一个，（反正我测我的没有bug）。点击保存会自动跳到下一个，然后重复 2.3两步3就ok 3. 其他： 本教程仅仅为了方便大家评教，自动选择后可以修改，评教系统是安医非常重要的反映师生关系的环节，请大家如实提交","link":"/2020/01/09/Anyipingjiao/"},{"title":"客户端存储localStorage、sessionStorage、cookies方法及特点","text":"localStorage https://juejin.im/post/5a9fcc5e51882555602074e3","link":"/2020/01/06/storageBro/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"电路","slug":"电路","link":"/tags/%E7%94%B5%E8%B7%AF/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"cms配置","slug":"cms配置","link":"/tags/cms%E9%85%8D%E7%BD%AE/"},{"name":"arduino","slug":"arduino","link":"/tags/arduino/"},{"name":"电子设计大赛","slug":"电子设计大赛","link":"/tags/%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"},{"name":"nodeJs","slug":"nodeJs","link":"/tags/nodeJs/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"软件著作权","slug":"软件著作权","link":"/tags/%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"安医助手","slug":"安医助手","link":"/tags/%E5%AE%89%E5%8C%BB%E5%8A%A9%E6%89%8B/"}],"categories":[{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"电路","slug":"电路","link":"/categories/%E7%94%B5%E8%B7%AF/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"cms配置","slug":"cms配置","link":"/categories/cms%E9%85%8D%E7%BD%AE/"},{"name":"arduino","slug":"arduino","link":"/categories/arduino/"},{"name":"电子设计大赛","slug":"电子设计大赛","link":"/categories/%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"nodeJs","slug":"nodeJs","link":"/categories/nodeJs/"},{"name":"树莓派","slug":"树莓派","link":"/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"vscode","slug":"vscode","link":"/categories/vscode/"},{"name":"软件著作权","slug":"软件著作权","link":"/categories/%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"安医助手","slug":"安医助手","link":"/categories/%E5%AE%89%E5%8C%BB%E5%8A%A9%E6%89%8B/"}]}