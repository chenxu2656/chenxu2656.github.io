{"pages":[{"title":"aboutMe","text":"个人简介 姓名 ：许许如生年龄：1999性别：男所在地：安徽合肥email: chenxu2656@gmail.com教育经历 2016- 安徽医科大学 生物医学工程 （Biomedical engineering ， AnHui Medical University）技能及爱好 arduino、树莓派、前端、小程序项目经历 2018- 今 图形化编程应用平台2018- 今 图形化编程平台（面向前端开发）2019.4-今 基于webplus站群的前端主题开发 安徽医科大学财务处 安徽医科大学南校区管委会 安徽医科大学人事处 安徽医科大学纪委办公室 安徽医科大学留学生网 2019.7 用于小型场所（实验室）电子元器件及设备管理小程序 github： https://github.com/chenxu2656/celwx 比赛获奖及论文 [全国大学生电子设计大赛] [互联网+创新创业大赛] [大学生创新创业项目] [安徽省禁毒辩论赛]（♥champion♥） Zhen Liang, Runhuai Yang*, Chenchen Xu, Shaohui Hou, Guoqing Jin and Fuzhou Niu. The Simulation and Experiment Study of a Wearable, Flexible and Transparent Biomimetic Voltage Source. In: Okada H., Atluri S. (eds) Computational and Experimental Simulations in Engineering. ICCES 2019. Mechanisms and Machine Science, vol 75. Springer, Cham 其他 考研估计要凉，学学前端找工作啦！！！","link":"/about/index.html"},{"title":"donate","text":"如果对您有帮助 请代我向中国红十字会捐赠 捐款地址 https://mv.lingxi360.com/m/zjgw7x?utm_bccid=LXEhue1n","link":"/donate/index.html"}],"posts":[{"title":"电桥电路分析方法","text":"👉 https://zhuanlan.zhihu.com/p/32111487","link":"/2019/12/26/dianqiao1/"},{"title":"arduino(UNO、MEGA、DUE、Leonardo、YUN)-TFT接线方法","text":"==1. TFT引脚图== ==2. 各种板子的软件SPI== ==3. 接线及引脚==3.1 UNO接线 引脚 +5V: +5V MISO: pin 12 SCK: pin 13 MOSI: pin 11 LCD CS: pin 10 SD CS: pin 4 D/C: pin 9 RESET: pin 8 BL: +5V GND: GND 3.2 Leonardo、YUN接线 引脚 +5V: +5V MISO: Miso pin (white wire on ICSP) SCK: Sck pin (brown wire on ICSP) MOSI: Mosi pin (yellow wire on ICSP) LCD CS: pin 7 SD CS: pin 8 D/C: pin 0 RESET: pin 1 BL: +5V GND: GND 3.3 mega2560接线 引脚 +5V: +5V MISO: 50 on Mega 2560 (Miso on ADK) SCK: 52 on Mega 2560 (Sck on ADK) MOSI: 51 on Mega 2560 (Mosi on ADK) LCD CS: pin 10 SD CS: pin 4 D/C: pin 9 RESET: pin 8 BL: +5V GND: GND 3.4 Leonardo、YUN接线 引脚 +5V: +5V MISO: Miso pin (white wire on SPI) SCK: Sck pin (brown wire on SPI) MOSI: Mosi pin (yellow wire on SPI) LCD CS: pin 10 SD CS: pin 7 D/C: pin 9 RESET: pin 8 BL: +3.3V GND: GND ==4. 程序初始化模板== mega 2560为例 12345678910111213141516171819#include &lt;Arduino.h&gt;#include &lt;TFT.h&gt; // Arduino LCD library#include &lt;SPI.h&gt;#define cs 10#define dc 9#define rst 8TFT TFTscreen = TFT(cs, dc, rst);void setup() { // initialize the display TFTscreen.begin(); // black background TFTscreen.background(0,0,0); TFTscreen.stroke(255,255,255); //设置文字颜色为白色 TFTscreen.setTextSize(2); //设置显示文字大小 }void loop() { TFTscreen.stroke(255, 0, 0); // set the stroke color to red TFTscreen.line(0, 10, TFTscreen.width(), 10); // draw a line across the screen}","link":"/2019/12/26/arduino/"},{"title":"doracms 部署（node+mongodb的高性能服务器）基于docker","text":"==1. doracms==github：https://github.com/doramart/DoraCMS 官网：https://www.html-js.cn/ ==2. 安装docker== docker主要分为两个版本 docker CE (社区免费版) docker EE(收费版本)，我们使用社区免费版就行 安装一些必要的系统工具： 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息： 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存： 1sudo yum makecache fast 安装 Docker-ce： 1sudo yum -y install docker-ce 启动 Docker 后台服务 1sudo systemctl start docker 测试运行 hello-world 1docker run hello-world (先自动安装helloword的库然后运行) 查询docker版本 1docker -v ==3.安装doracms== 查询 DoraCMS 镜像 1docker search doracms 下载 DoraCMS 镜像 1docker pull doramart/doracms:2.1.2 查询镜像是否下载成功 1docker images 通过doracms镜像创建mycms 容器，并制定映射端口号*(==请在服务器打开你映射的端口否则可能无法访问==) 1docker run -it -d -p 8001:8080 --name mycms doramart/doracms:2.1.2 /bin/bash 查看端口号绑定情况： 1docker ps 开启redis 1redis-server /etc/redis/redis.conf &amp; 开启mongodb 123cd /usr/local/mongodb/mongodb-linux-x86_64-ubuntu1604-4.0.9/bin/./mongod --config /usr/local/mongodb/mongodb.conf 进入代码根目录，重装依赖（本身镜像中有依赖，建议删除重新安装一次），依次执行下面的命令 1234567cd /home/webapp/DoraCMS/git pullrm -rf node_modules/npm i 让环境变量生效,镜像中在 /etc/profile 中配置了 export NODE_ENV=production, 但是需要source一下使其生效： 1source /etc/profile 通过pm2 启动项目 1pm2 start server.js --name doracms 在本地通过 http://localhost:8001 访问，可以看到，页面已经打开了。 ==4. 常见问题==重启服务器网站无法访问 我做了一个快照，但是重启服务器后网站无法访问，猜测是某些服务没打开，但是不知道是哪些服务没开，所以试着开一下所有服务 打开进入容器 12docker start containerIDdocker attach containerID 查一下运行状态 1pm2 list 发现是空的 我用Pm2重启服务之后发现还是打不开，然后我就跟着安装步骤把每个服务都重启了一下发现可以运行了。开启redis 1redis-server /etc/redis/redis.conf &amp; 开启mongodb123cd /usr/local/mongodb/mongodb-linux-x86_64-ubuntu1604-4.0.9/bin/./mongod --config /usr/local/mongodb/mongodb.conf 进入代码根目录1cd /home/webapp/DoraCMS/ 让环境变量生效,镜像中在 /etc/profile 中配置了 export NODE_ENV=production, 但是需要source一下使其生效：1source /etc/profile 通过pm2 启动项目1pm2 start server.js --name doracms","link":"/2019/12/26/doracms/"},{"title":"javascript遍历json数组","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;动态表格&lt;/title&gt;&lt;/head&gt;&lt;style&gt; table { border-collapse: collapse; } tr { height: 30px; } th, td { width: 150px; border: 1px solid black; text-align: center; } .deletData { color: red; }&lt;/style&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;学科&lt;/th&gt; &lt;th&gt;分数&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; var data = [ { name: '魏璎珞', item: 'javascaript', grade: '100', operation: 'deleteDate' }, { name: '弘历', item: 'javascaript', grade: '10', operation: 'deleteDate' }, { name: '傅恒', item: 'javascaript', grade: '1000', operation: 'deleteDate' }, { name: '明玉', item: 'javascaript', grade: '99', operation: 'deleteDate' }, { name: '大猪蹄子', item: 'javascaript', grade: '99', operation: 'deleteDate' } ] var tableDate = document.querySelector('table'); for (var i = 0; i &lt; data.length; i++) { var creatItem = document.createElement('tr'); tableDate.appendChild(creatItem); // 遍历 json for (allCon in data[i]) { var creatTd = document.createElement('td'); // console.log(allCon) creatTd.innerHTML = data[i][allCon]; creatItem.appendChild(creatTd); if (allCon == 'operation') { // 给删除加一个删除类 creatTd.className = 'deletData'; } } } // 点击删除后删除节点 var deletDataButton = document.querySelectorAll('.deletData'); // console.log(deletDataButton.length); for (var z = 0; z &lt; deletDataButton.length; z++) { deletDataButton[z].onclick = function () { // 点击触发 var flag = confirm('请谨慎删除,确定是否要删除？'); if (flag) { var shouldDelet = this.parentNode; shouldDelet.parentNode.removeChild(shouldDelet); } else { alert('未删除'); } } }&lt;/script&gt;&lt;/html&gt;","link":"/2019/12/27/javacriptJson/"},{"title":"docker修改映射端口号","text":"大家都知道docker run可以指定端口映射，但是容器一旦生成，就没有一个命令可以直接修改。通常间接的办法是，保存镜像，再创建一个新的容器，在创建时指定新的端口映射,但是这种方法比较麻烦。牛人还是有奇招的：https://stackoverflow.com/questions/19335444/how-do-i-assign-a-port-mapping-to-an-existing-docker-container 停止容器 1docker stop containerID 停止docker服务 1systemctl stop docker 修改这个容器的hostconfig.json文件中的端口（如果有多个版本都需要修改） centos一般默认的docker container目录在这进入这个目录 1cd /var/lib/docker/containers/8bee1db654916998ae2e4c716481209f290d521b74dc997bbd37cb8d9f856cc4 1vi hostconfig.json 修改下面这个端口号就行，这里我已经修改过了 启动docker服务1systemctl start docker 5) 启动容器 1docker start containerID 如果修改完之后没有正常运行，请检查原有的服务是否开启，因为有时有的服务需要重启一下","link":"/2019/12/25/docker3/"},{"title":"centos7配置docker","text":"docker主要分为两个版本 docker CE (社区免费版) docker EE(收费版本)，我们使用社区免费版就行 安装一些必要的系统工具： 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息： 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存： 1sudo yum makecache fast 安装 Docker-ce： 1sudo yum -y install docker-ce 启动 Docker 后台服务 1sudo systemctl start docker 测试运行 hello-world 1docker run hello-world (先自动安装helloword的库然后运行) 查询docker版本 1docker -v","link":"/2019/12/25/docker1/"},{"title":"javascript节点操作","text":"1. 节点类型基础常用 元素节点 nodeType = 1 = 常用 属性节点 nodeType = 2 文本节点 nodeType = 3 注释节点 nodeType=8 节点三个基本属性 nodeType 代表不同的节点类型 nodeName 对于元素节点，nodeName=标签名（返回的名称是大写的） 对于文本节点，nodeName=’#text’ nodeValue 对于文本节点，nodeValue=文本内容 对于元素节点，返回undefined 因为元素节点本身不含内容 1234567891011121314151617181920//示例代码&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 下面输出为3 包含两个文本节点和一个元素节点 console.log(obj.childNodes); // 输出 #text console.log(obj.childNodes[0].nodeName); // 输出 LI console.log(obj.childNodes[1].nodeName); // 输出 你好不好反正我不好 console.log(obj.childNodes[0].nodeValue); // 输出 undefined console.log(obj.childNodes[1].nodeValue);&lt;/script&gt; 2. 获取父节点1. element.parerntNode123456789101112&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('li'); console.log(obj.parentNode); // parentElement 一般和parentNode一样，只有nodeType!==1的时候，即父节点不是Element的时候，通过parentElement得到的父节点会是null； console.log(obj.parentElement);&lt;/script&gt; 输出 1234&lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;/div&gt; 3. 获取子节点 children 只返回 元素节点 非常好用 childNodes 会获取包含元素、文本等所有节点 返回一个数组 不常用 12345678910111213&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // childNodes 会获取包含元素、文本等所有节点 返回一个数组 不常用 console.log(obj.childNodes); // children 只返回 元素节点的数组 非常好用 console.log(obj.children);&lt;/script&gt; 4. 获取第一个子节点和最后一个节点 children[0] 返回元素节点的数组 数组第一个元素 fisrstchild 会把第一个文本节点也包含起来 并不是很好用 firstElementChild只返回第一个元素节点 非常好用 12345678910111213141516&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; 你好不好反正我不好 &lt;li&gt;hi&lt;/li&gt; &lt;li&gt;拜拜啦您嘞&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // children 返回元素节点的数组 数组第一个元素 console.log(obj.children[0]); // Fisrstchild会把第一个文本节点也包含起来 并不是很好用 console.log(obj.firstChild); // firstElementChild只返回第一个元素节点 非常好用 console.log(obj.firstElementChild);&lt;/script&gt; 把first换成last就可以得到最后一个节点5. 获取兄弟节点 nextSibling 下一个节点 会包含各种节点 nextElementSibling 只会获取下一个元素节点 previousSibling 上一个节点 会包含各种节点 previousElementSibling 只会获取上一个元素节点 6. 创建、添加、删除节点 creatElememt(‘tagname’) 创建节点 Node.AppendChild(child) 在node父节点的最后添加一个子节点 相当于 push Node.insertBefore(child,指定子节点) 在node父节点中的指定子节点之前添加子节点 Node.removeChlid(child) 删除指定节点 1234567891011121314151617181920212223&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 选择原有节点 var firstLi = document.querySelector('li'); console.log(firstLi); // 创建一个节点 var newLi = document.createElement('li'); newLi.innerHTML='2' // 插入节点 默认会在最后插入 obj.appendChild(newLi); // 新创建一个节点 var newLi2 = document.createElement('li'); newLi2.innerHTML='0' // 指定位置插入节点 把新创建的newLi2节点插入到 firstLi前面 obj.insertBefore(newLi2,firstLi); // 删除指定节点 obj.removeChild(firstLi);&lt;/script&gt; 7. 克隆节点 node.cloneNode(deep); deep==false或者留空 浅拷贝 , deep==true 深拷贝 12345678910111213141516&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 选择原有节点 var firstLi = document.querySelector('li'); // cloneNode(参数1) 参数1默认是 false 当留空或者是false时 默认浅拷贝 var clone1 = firstLi.cloneNode(); // cloneNode(true) 深拷贝 会拷贝内部内容 var clone2 = firstLi.cloneNode(true); obj.appendChild(clone1); obj.appendChild(clone2);&lt;/script&gt;","link":"/2019/12/27/javascriptJieDian/"},{"title":"javascript修改页面css样式","text":"1.element.style 不会清除原来的任何属性 123456789101112131415161718&lt;style&gt;.oldClass{ color: red;}&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;oldClass&quot; style=&quot;width: 200px ;height: 200px; border: red 1px solid;&quot;&gt; hi xuxurusheng &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector('div'); div.onclick = function (){ this.style.backgroundColor='yellow'; }&lt;/script&gt;// 直接使用 element.style// 注意后面属性（backgroundColor）是驼峰命名法 2. cssText 不会清除内部属性，但是回去清除内嵌属性 12345678910111213141516171819202122&lt;style&gt;.oldClass{ color: red;}&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;oldClass&quot; style=&quot;width: 200px ;height: 200px; border: red 1px solid;&quot;&gt; hi xuxurusheng &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector('div'); div.onclick = function (){ this.style.cssText=&quot;background-color:yellow&quot;; // 这样写会把内嵌样式给替换掉 运行结果是 红字黄底 但是宽高都没有了 }&lt;/script&gt;``` ## 3. obj.className 来修改或者增加元素类 ---会替换掉原来的内部样式，但是不会替换掉内嵌样式。如果想保留原来的类可以用空格把几个类都隔起来 .oldClass{ color: red; } .newClass{ background-color: yellow; } hi xuxurusheng var div = document.querySelector('div'); div.onclick = function (){ // 这种方法文字颜色会为黑色 背景会变成黄色 this.className='newClass'; // 这种方法文字颜色不会为黑色，还是红色。 背景会变成黄色 this.className='oldClass newClass'; // 这两种方法都不会改变 style=\"width: 200px ;height: 200px; border: red 1px solid;\" 这一内嵌样式 } 1234## 4. setAttribute ---这个方法可以设置各种属性。不仅可以设置 css， // 1. 方法1 这种方法和 className用法没有区别 .oldClass{ color: red; } .newClass{ background-color: yellow; } hi xuxurusheng var div = document.querySelector('div'); div.onclick = function (){ // 这种方法文字颜色会为黑色 背景会变成黄色 this.setAttribute(\"class\", \"newClass\"); // 这种方法文字颜色不会为黑色，还是红色。 背景会变成黄色 this.setAttribute(\"class\", \"oldClass newClass\"); // 这两种方法都不会改变 style=\"width: 200px ;height: 200px; border: red 1px solid;\" 这一内嵌样式 } 12345678```//2. 可以通过 setAttribute 修改link里面的href 更改一个css文件，当然这个基本用不到&lt;link href=&quot;old.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; id=&quot;css&quot;/&gt; div.onclick = function (){ var css = document.getElementById(&quot;css&quot;); css.setAttribute(&quot;href&quot;,&quot;css2.css&quot;); }","link":"/2019/12/27/jsCss/"},{"title":"基于node+mongodb的简易服务器搭建（window）配合ESP8266进行物联网","text":"准备工作 在磁盘根目录下新建一个文件夹 server (避免路径出现中文报错)，然后server下新建两个文件夹 node、mongodb 把这两个安装包下载下来(直接点击下载，用了CDN比官网快) node.js : http://files.qianduan.ltd/node-v8.12.0-x64.msi mongodb : http://files.qianduan.ltd/mongodb-win32-x86_64-2008plus-ssl-4.0.9-signed.msi 安装node.js node 安装比较简单，主要注意安装路径 1. 安装目录选中到刚才的 server/node 2. 测试是否安装成功 12345win+R 打开运行输入 cmdnode -v //查询安装版本号 出现版本号则说明成功 安装mongodb1. 安装路径选择 server/mongodb 2. 关于数据和日志 这一部分主要用于设置用户密码，数据日志，这里mongo做了改进以前还需要手动创建，这里我们保持默认就行，本地测试不需要设置密码 3. 取消勾选图形界面 取消勾选，否则会装不上。如果大家想试一下可以在vscode安装mongodb插件相关插件也非常好用 4. 测试 进入目录 F:\\server\\mongodb\\bin 运行 mongo.exe 1show dbs //查看所有数据库 mongodb安装端口是 27017 访问 127.0.0.1:27017 运行服务器文件准备 首先下载我写好的服务器文件http://files.qianduan.ltd/DS-WEB.rar并解压，把解压好的服务器文件整个复制到 server文件夹下文件目录： public存放静态文件（一定要放在public下，否则node报错） index.js 服务器配置文件 index.html 前端主页1. 安装引入的模块（及把index.js里面require的模块给安装下来） 大家自行查看js文件可以看到我们引入了哪些3模块，我做了简单的注解 1. 进入DS-WEB文件夹，输入cmd回车进入命令行2. 分别执行以下代码 1234567891011121314// 事件监听npm install events // 操作数据库的工具npm install mongoosenpm install netnpm install body-parsernpm install expressnpm install http// 事件发射器 可实现双向通信npm install socket.io 3.重开命令窗口运行 node index.js可以看到服务器应在在运行 端口号 3000 监听硬件端口号 8000 最下面是我的web板子，可以看到已经连接上我的服务器 4. 进入浏览器打开 localhost:3000 服务器已经正常运行 5. 安装进程管理工具 这时候我们把node的命令框关掉然后刷新网页发现已经不能运行了,所以我们安装一个进程管理工具来保障服务运行，进行管理工具有很多 比如 forever、pm2我比较习惯用pm2123win+R ---&gt; cmd ---&gt;进入黑框框npm install pm2 -g 进入DS-WEB文件夹，进入命令框用pm2启动服务1pm2 start index.js 可以看到服务正在运行 6. 补充几个pm2常用命令123pm2 start X //启动服务pm2 stop X //停止服务pm2 list // 服务列表","link":"/2019/12/26/dsweb/"},{"title":"javascript操作元素属性","text":"1. js获取元素属性 1. attributes 获取指定元素所有属性返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象 12345678910&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); console.log(obj.attributes); for (let i = 0; i &lt; obj.attributes.length; i++) { console.log(obj.attributes[i]); }&lt;/script&gt; 2.获取指定属性 element.属性只能获取内置属性值 123456789&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); console.log(obj.id); // 这里要使用 className 而不能使用class console.log(obj.className);&lt;/script&gt; 3. getAttribute不仅可以获取内置属性。还可以获取自定义属性值.自定义属性值用data-开头 12345678910&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 使用class就可以 不需要用classname console.log(obj.getAttribute('class')); // 还可以获取自定义属性值 console.log(obj.getAttribute('data-test'));&lt;/script&gt; 2. 修改属性 1. setAttribute用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。 element.setAttribute(&apos;属性名&apos;,&apos;属性值&apos;);1234567891011121314151617181920212223&lt;style&gt;.oldClass{ color: red;}.newClass{ background-color: yellow;}&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;oldClass&quot; style=&quot;width: 200px ;height: 200px; border: red 1px solid;&quot;&gt; hi xuxurusheng &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div = document.querySelector('div'); div.onclick = function (){ // 这种方法文字颜色会为黑色 背景会变成黄色 this.setAttribute(&quot;class&quot;, &quot;newClass&quot;); // 这种方法文字颜色不会为黑色，还是红色。 背景会变成黄色 this.setAttribute(&quot;class&quot;, &quot;oldClass newClass&quot;); // 这两种方法都不会改变 style=&quot;width: 200px ;height: 200px; border: red 1px solid;&quot; 这一内嵌样式 }&lt;/script&gt; 2. dataset方法dataset实现的功能用setattribute都可以实现，速度比setattribute慢一点。自定义属性一般使用data- 开头 ，dataset是专门针对这种自定义属性的 获取 删除 创建123456789101112131415161718&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); // 当然 getAttribute 可以解决所有问题 console.log(obj.getAttribute('data-test')); // 针对data-开头 使用dataset只需要把 data-后面的属性写进去 obj.dataset.test=&quot;hello&quot;; console.log(obj.dataset.test); // 对于多个横杠连接的 data-foo-word 调用时需要使用驼峰命名 fooWord console.log(obj.dataset.fooWord); // 删除某一指定属性 delete obj.dataset.fooWord; // 创建一个属性原本没有的属性 obj.dataset.newCreat='ok'; console.log(obj.dataset.newCreat);&lt;/script&gt; 运行结果 data-foo-word被删除 data-new-creat 被创建 3. 移除属性 1. Element.removeAttribute()Element.removeAttribute方法用于从当前元素节点移除属性。 1234// &lt;div id=&quot;div1&quot; align=&quot;left&quot; width=&quot;200px&quot;&gt;document.getElementById('div1').removeAttribute('align');// 现在的HTML代码为// &lt;div id=&quot;div1&quot; width=&quot;200px&quot;&gt; 2. delet element.dataset.属性名删除一个自己创建的data-*属性，代码如上 4. 查询属性 hasAttribute() 方法返回一个布尔值，表示当前元素节点是否包含指定属性 123456789&lt;body&gt; &lt;div class=&quot;Class&quot; id=&quot;Id&quot; data-test=&quot;test&quot; data-foo-word=&quot;foo-word&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var obj = document.querySelector('div'); if (obj.hasAttribute('data-test')) { console.log(obj.hasAttribute('data-test')); }&lt;/script&gt; 输出 ： true","link":"/2019/12/27/jsShuxing/"},{"title":"docker常用命令","text":"查询镜像1docker search IMAGENAME 下载镜像 1docker pull IMAGENAME 查询已下载镜像 1docker images 查询容器列表 1docker ps 删除一个容器实例 1sudo docker rm CONTAINERID 删除所有容器 1sudo docker rm sudo docker ps -aq 停止一个正在运行的容器 1sudo docker kill CONTAINERID 重启一个正在运行的容器 1sudo docker restart CONTAINERID 开启一个已经停止的容器 1sudo docker start CONTAINERID 删除镜像，从本地删除一个已经下载的镜像 先查看正在运行的 容器 1docker ps 结束正在运行的容器 1docker kill containerid 删除正在运行的容器 1docker rm CONTAINERID 删除镜像 1docker rmi imageid ==注意 rm 和 rmi 分别用来删除容器和镜像== 退出当前镜像1exit","link":"/2019/12/25/docker2/"},{"title":"javascript选择器","text":"元素获取方法汇总 获取某个Id1getElementById('idName'); 获取某个 ClasaName1getElementByClassName() 根据标签名获取返回的是一个伪数组 1getElementByTagName() 获取body 返回的是 节点 1Document.body 获取html对于任何非空 HTML 文档，调用 document.documentElement 总是会返回一个 元素，且它一定是该文档的根元素。借助这个只读属性，能方便地获取到任意文档的根元素。 1document.documentElement querySelector需要指明name的具体属性 比如 #name .name 等返回的是制定选择器的第一个元素对象 1querySelector(&quot;name&quot;) querySelectorAll需要指明name的具体属性 比如 #name .name 等返回的是制定选择器所有对象集合（一个数组） 1querySelectorAll(&quot;name&quot;)","link":"/2019/12/27/javascriptSelect/"},{"title":"mysql常见问题及解决方案","text":"忘记密码、设置初始密码 用命令编辑/etc/my.cnf配置文件 1vi /etc/my.cnf [mysqld]下添加skip-grant-tables，然后保存并退出 1skip-grant-tables 重启mysql服务 1service mysqld restart 进入服务器直接就可以登录不需要密码 1mysql 修改密码,刷新权限，退出 123UPDATE mysql.user SET Password=PASSWORD('新密码') where USER='root';flush privileges;exit 删除掉刚才添加的 skip-grant-tables 用新密码登录即可 1mysql -u root -p 引用：https://www.linuxidc.com/Linux/2018-05/152586.htm","link":"/2019/12/26/mysqlQuestions/"},{"title":"js鼠标事件汇总","text":"1. js鼠标事件汇总 onclick&amp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当用户点击某个对象时调用的事件句柄。 oncontextmenu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在用户点击鼠标右键打开上下文菜单时触发 ondblclick &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户双击某个对象时调用的事件句柄。 onmousedown &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标按钮被按下。 onmouseenter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当鼠标指针移动到元素上时触发。 onmouseleave &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当鼠标指针移出元素时触发 onmousemove &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标被移动。 onmouseover &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标移到某元素之上。 onmouseout &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标从某元素移开。 onmouseup &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标按键被松开。 2. 事件触发事件源+事件类型+事件处理程序 12345var shijianyuan = document.getElementById('tijiao'); // 事件源shijianyuan.onclick = function(event){ // onclick 为事件触发类型 // function 内为事件触发函数} 3. 触发时的参数event为MouseEvent对象类型： type &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件类型，如’mosemove’或者’mousedown’ button&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整型，触发鼠标事件时按下的按钮编号 buttons&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整型，触发鼠标事件时弹起来的按钮编号 [x]clientX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在DOM内容区的X坐标 [x]X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上 [x]clientY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在DOM内容区的Y坐标 [x]Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上 [x]offsetX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针相对父节点填充边缘的X坐标 [x]offsetY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标指针相对父节点填充边缘的Y坐标 [x]screenX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在全局屏幕的X坐标 [x]screenY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在全局屏幕的Y坐标 [x]pageX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在整个DOM内容（包括分页）的X坐标 [x]pageY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在整个DOM内容（包括分页）的Y坐标 [x]altKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的alt键和鼠标是否同时按下 [x]ctrKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的alt键和鼠标是否同时按下 [x]shiftKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的shift键是和鼠标是否同时按下 [x]metaKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，windows平台表示Window键是否同时按下，mac表示Command键是否同时按下 12345678910# 示例程序返回点击时鼠标的坐标&lt;body&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log(MouseEvent.x); } &lt;/script&gt;&lt;/body&gt; 4. offsetY 、 screenY 、 clientY (y) 、 pageY的区别12345678910111213141516&lt;body style=&quot;height: 2000px;&quot;&gt; &lt;html&gt; &lt;div style=&quot;width: 500px; height: 500px; background-color: aqua; margin: 200px auto auto 200px; padding: 100px;&quot;&gt; &lt;div style=&quot;width: 200px; height: 200px; background-color: brown;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/html&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log('clienty的坐标是'+MouseEvent.y); console.log('pagey的坐标是'+MouseEvent.pageY); console.log('offsety的坐标是'+MouseEvent.offsetY); console.log('screeny的坐标是'+MouseEvent.screenY); } &lt;/script&gt;&lt;/body&gt; 运行结果 offsetY相对于父节点的位置而言 screenY相对于整个显示器的位置而言 clientY相对于当前页面的位置而言 offsetY相对于当前页面+纵向滚动距离（）的位置而言","link":"/2019/12/26/mouse/"},{"title":"Javascript选择器","text":"1. 获取某个Id1getElementById('idName'); 2. 获取某个 ClasaName1getElementByClassName() 3. 根据标签名获取返回的是一个伪数组 1getElementByTagName() 4. 获取body 返回的是 节点 1Document.body 5. 获取html对于任何非空 HTML 文档，调用 document.documentElement 总是会返回一个 元素，且它一定是该文档的根元素。借助这个只读属性，能方便地获取到任意文档的根元素。 1document.documentElement 6. querySelector需要指明name的具体属性 比如 #name .name 等返回的是制定选择器的第一个元素对象 1querySelector(&quot;name&quot;) 7. querySelectorAll需要指明name的具体属性 比如 #name .name 等返回的是制定选择器所有对象集合（一个数组） 1querySelectorAll(&quot;name&quot;)","link":"/2019/12/26/javascript1/"},{"title":"centos7.x 安装nodeJs","text":"1.安装gcc，make，openssl，wget1yum install -y gcc make gcc-c++ openssl-devel wget 2.下载源代码包 官方地址：https://nodejs.org/en/download/ 1wget https://nodejs.org/dist/v9.3.0/node-v9.3.0.tar.gz 3.解压源代码包1tar -xf node-v9.3.0.tar.gz 4.编译进入源代码所在路径1cd node-v9.3.0 执行配置脚本1./configure 编译与部署1make &amp;&amp; make install 接着就是等待编译完成… 5.测试node版本号1node -v npm版本号1npm -v ==作者 ：XCC ==","link":"/2019/12/26/nodeJs2/"},{"title":"javscript 鼠标事件","text":"js鼠标事件汇总 事件触发事件源+事件类型+事件处理程序 12345var shijianyuan = document.getElementById('tijiao'); // 事件源shijianyuan.onclick = function(event){ // onclick 为事件触发类型 // function 内为事件触发函数} 触发时的参数event为MouseEvent对象类型： 123456789# 示例程序返回点击时鼠标的坐标&lt;body&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log(MouseEvent.x); } &lt;/script&gt;&lt;/body&gt; offsetY 、 screenY 、 clientY (y) 、 pageY的区别12345678910111213141516&lt;body style=&quot;height: 2000px;&quot;&gt; &lt;html&gt; &lt;div style=&quot;width: 500px; height: 500px; background-color: aqua; margin: 200px auto auto 200px; padding: 100px;&quot;&gt; &lt;div style=&quot;width: 200px; height: 200px; background-color: brown;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/html&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log('clienty的坐标是'+MouseEvent.y); console.log('pagey的坐标是'+MouseEvent.pageY); console.log('offsety的坐标是'+MouseEvent.offsetY); console.log('screeny的坐标是'+MouseEvent.screenY); } &lt;/script&gt;&lt;/body&gt; 运行结果 offsetY相对于父节点的位置而言 screenY相对于整个显示器的位置而言 clientY相对于当前页面的位置而言 offsetY相对于当前页面+纵向滚动距离（）的位置而言","link":"/2019/12/27/javascriptMouse/"},{"title":"树莓派使用基础教程（1）系统安装及远程登陆","text":"系统安装 树莓派提供了系统安装工具NOOBS 1. 进入下载页面 左侧是 图形化界面的系统、右侧是不带图形化界面的系统，没什么区别 https://www.raspberrypi.org/downloads/ 我们选右边这个，高级一点 2. 选择一种方式下载（迅雷好像快一点） 网盘我也存了一份：https://pan.baidu.com/s/1QFVUocKJpe1QmxssRWuRHg 3. 解压 解压下来是这个样子，目录不要含有中文，不然做系统盘会出错 4. 格式化sd卡，格式化成FAT 感觉格式化完内存显示有问题用磁盘管理工具重新分一下区然后重新格式化 5. 下载系统写入工具 推荐使用 diskimage，扔个CDN加速的下载链接给你：http://files.qianduan.ltd/win32diskimager-1.0.0-install.exe 6. 写入系统文件 7. emmm快成功了通过ssh链接1. 在boot目录下写入 SSH文件2. 在根目录下新建```12 country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={ ssid=”WiFi-A” psk=”12345678” key_mgmt=WPA-PSK priority=1} 12345678910111213141516171819202122&gt; #ssid:网络的ssid&gt; #psk:密码&gt; #priority:连接优先级，数字越大优先级越高（不可以是负数）&gt; #scan_ssid:连接隐藏WiFi时需要指定该值为1&gt; #key_mgmt:加密方式 （进路由器后台看）&gt;&gt; ``` key_mgmt=WPA-PSK ``` :使用WPA/WPA2加密(一般都是这个)&gt;&gt; ``` key_mgmt=NONE ``` ：WEP加密![image](http://image.qianduan.ltd/s10.png)#### 3. 把sd卡安装至卡槽，上电启动#### 4. 查看树莓派IP &gt; 1. 可以通过路由器后台查看![image](http://image.qianduan.ltd/s5.png)&gt; 2. 用命令ping一下``` ping -4 raspberrypi 默认ping出的是IPV6，所以加个 -4 强制转换一下 5. 下载个远程登陆工具 xshell （相对较专业）和 putty（开源轻便） 选一个：https://qdzy.xccstu.top/qdzy/site/yzrj.html 6. 登录 输入刚才ping到的IP 默认用户名：pi 默认密码：raspberry","link":"/2019/12/25/rpiPre1/"},{"title":"树莓派使用基础教程（2）系统安装及远程登陆","text":"1. 查询raspberrypi自带python版本 python2版本 2.7.16（默认使用） python3版本 3.7.3 退出python ：CTRL+D 2. 添加注释1# 3. 变量 区分大小写 ==实际没有变量实际是对变量对象的引用== 避免变量名与关键字重复 123456789# 查看关键字pi@raspberrypi:~/code $ python3Python 3.7.3 (default, Apr 3 2019, 05:39:12) [GCC 8.2.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import keyword&gt;&gt;&gt; print(keyword.kwlist)['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']&gt;&gt;&gt; 变量名第一个字符只能是字母和下划线 长（多）字符串赋值 查询变量类型 1type(变量名) 4. 运算 普通运算和别的语言一样特殊运算1. 分数对象 ==Fraction==12from fractions import Fraction #引入模块创建对象test = Fraction(分子,分母) #创建的分数对象可以进行数字运算 实例 12345&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt; test=Fraction(2,6)&gt;&gt;&gt; print(test)1/3&gt;&gt;&gt; 2. 复数操作 3. math模块 和别的函数的math对象基本相同https://blog.csdn.net/iamaiearner/article/details/9381347整体引入 12import math #引入模块math.funcname() #调用 单个引入 12from math import funcname # 引入单个模块funcname( ) # 直接调用 4. 数组处理 NumPy模块1import numpy 5. 控制语句 没什么特别的 强依赖缩进+冒号 1234if: print()else: print() 6. 循环语句 语法结构和js相似， 强依赖缩进+冒号 12345# for in 循环for the_number in [1,2,3,4,5]:### . 常用命令#### 1. print() python3 print(argument) 12345678910- 字符&gt; 单引号或者双引号&gt; 三重引号实现带格式输出 (使用转义符\\n效果一样)![image](http://image.qianduan.ltd/po1.png)&gt; 代码``` print(&quot;&quot;&quot; 第一行 第二行 第三行&quot;&quot;&quot;) 输出 12345pi@raspberrypi:~/code $ python3 test3.py 第一行 第二行 第三行","link":"/2019/12/25/rpiPre2/"},{"title":"树莓派使用基础教程（4）自定义模块调用","text":"先创建一个自定义模块 123# libtest.pydef AaaB(): print(&quot;happy~&quot;) 库文件调用1. 同目录调用 test5.py libtest.py 123# test5.py codeimport libtest # 引入模块文件libtest.AaaB() # 运行相应函数 2. 不同目录下调用 为了不让文件过于混乱，通常新建一个lib的文件夹，即目录以如下方式呈现 test5.py lib libtest.py 12345# test5.py codeimport syssys.path.append(&quot;/home/pi/code/lib&quot;) # 绝对目录import libtestlibtest.AaaB()","link":"/2019/12/25/rpiPre4/"},{"title":"树莓派实战（3）按键控制小灯","text":"程序12345678910import RPi.GPIO as GPIO GPIO.setmode(GPIO.BOARD) #引脚编码方式GPIO.setup(7,GPIO.OUT,initial=GPIO.LOW) # 小灯，7号引脚，默认不亮,输出GPIO.setup(11,GPIO.IN) # 按键读取while True: statue=GPIO.input(11) # 读取按键是否被按下 if statue==1: GPIO.output(7, GPIO.HIGH) else: GPIO.output(7, GPIO.LOW) 接线图 知识点 程序控制语句 if else注意书写格式就行","link":"/2019/12/25/rpiUse3/"},{"title":"树莓派实战（1）：点亮小灯","text":"就像学习哦计算机语言第一步往往是输出一个 hello world一样，玩板子第一步一定是点个灯 程序12345import RPi.GPIO as GPIOGPIO.setmode(GPIO.BOARD)GPIO.setup(7,GPIO.OUT)while True: GPIO.output(7,GPIO.HIGH) 知识点树莓派使用的是GPIO的模块用来控制引脚，所谓GPIO也就是==general-purpose input/output==通用输入输出接口123# 1. 引入 GPIO模块import RPi.GPIO as GPIO GPIO控制引脚的编码方式主要有三种 按照插座编号编码 （==header==） BCM编号方式(==BCM GPIO==) wiringPi编号方式 (==wiringPi==) 一般采用第一种或者第二种那个习惯用哪个，第三种主要注重逻辑，可以但没必要。 12345# 编号方式设定GPIO.setmode(GPIO.BOARD) #第一种GPIO.setmode(GPIO.BCM) # 第二种 设置通道工作方式123#用作输入GPIO.setup(channel, GPIO.IN) 1234#用作输出GPIO.setup(channel, GPIO.OUT) GPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH) #为引脚设置默认值 设置通道的逻辑值123456# 输入通道GPIO.input(channel) #读取通过的逻辑值，比如按键事件# 返回0 / GPIO.LOW / False or 1 / GPIO.HIGH / True. 1234567891011121314#输出通道GPIO.output(channel, state)# statue：GPIO.HIGH / GPIO.LOW也可以同时设置多个通道输出chan_list = [11,12] GPIO.output(chan_list, GPIO.LOW) GPIO.output(chan_list, (GPIO.HIGH, GPIO.LOW))# 第一个11是高电平、12是低电平 清空引脚1GPIO.cleanup()","link":"/2019/12/25/rpiUse1/"},{"title":"vscode使用技巧","text":"设置多个光标在多处编辑1. alt+鼠标左键 可以多次点击设置多个光标2. ctrl+alt+键盘上下键 可以在当前位置上下3. 用鼠标选中一块区域 shift+alt+i 可以在这一个区域每一行的行末出现光标4. Ctrl + U 取消这些操作同时选中一篇代码所有相同字符串1. 用鼠标选中一个字符串 ctrl+shift+L 可以在全篇选取2. ctrl+h","link":"/2019/12/27/vscodeSkills/"},{"title":"树莓派使用基础教程（3）文件操作","text":"1. 操作文件 主要针对文本文件 文件常用命令 (python) 查询当前目录文件 123&gt;&gt;&gt; os.listdir()['test2.py', 'test1.py', 'test3.py']&gt;&gt;&gt; 创建文件 1234&gt;&gt;&gt; import os&gt;&gt;&gt; filename=&quot;test4.py&quot;&gt;&gt;&gt; os.mknod(filename)&gt;&gt;&gt; 修改文件名 12&gt;&gt;&gt; os.rename(&quot;test4.py&quot;,&quot;test5.py&quot;)&gt;&gt;&gt; 删除文件 12&gt;&gt;&gt; os.remove(&quot;test5.py&quot;)&gt;&gt;&gt; 打开文件 1&gt;&gt;&gt; test=open(&quot;test.txt&quot;) 写入文件 123456789101112131415&gt;&gt;&gt; test=open(&quot;test.txt&quot;) # 打开文件&gt;&gt;&gt; testnum=10 #定义写入变量&gt;&gt;&gt; test.write(testnum) #写入函数 openTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: write() argument must be str, not int # 报错，写入文件类型只能是数字&gt;&gt;&gt; teststring=&quot;123456&quot; # 写一个字符串重新写入&gt;&gt;&gt; test.write(teststring)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;io.UnsupportedOperation: not writable #再次报错，文件只读 &gt;&gt;&gt; test=open(&quot;test.txt&quot;,&quot;w&quot;) #重新打开文件，mode写成 “w” “a”不会擦除 可写。但是w会移除原有内容&gt;&gt;&gt; test.write(teststring)6&gt;&gt;&gt; 读取文件 1234567&gt;&gt;&gt; testread=open(&quot;test.txt&quot;,&quot;r&quot;)&gt;&gt;&gt; test_data=testread()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '_io.TextIOWrapper' object is not callable&gt;&gt;&gt; test_data=testread.read()&gt;&gt;&gt; print(test_data) 2. 函数 定义函数 1234def funcname(): statement1 #参数 statement2 return value #返回值 调用函数1funcname() 设定参数默认值1def funcname(width,height=20): 3. 模块 列出一个模块所有函数1234&gt;&gt;&gt; import os &gt;&gt;&gt; dir(os) #列出所有函数['CLD_CONTINUED', 'CLD_DUMPED', 'CLD_EXITED', 'CLD_TRAPPED', 'DirEntry', 'EX_CANTCREAT', 'EX_CONFIG', 'EX_DATAERR', 'EX_IOERR', 'EX_NOHOST', 'EX_NOINPUT', 'EX_NOPERM', 'EX_NOUSER', 'EX_OK', 'EX_OSERR', 'EX_OSFILE', 'EX_PROTOCOL', 'EX_SOFTWARE', 'EX_TEMPFAIL', 'EX_UNAVAILABLE', 'EX_USAGE', 'F_LOCK', 'F_OK', 'F_TEST', 'F_TLOCK', 'F_ULOCK', 'GRND_NONBLOCK', 'GRND_RANDOM', 'MutableMapping', 'NGROUPS_MAX', 'O_ACCMODE', 'O_APPEND', 'O_ASYNC', 'O_CLOEXEC', 'O_CREAT', 'O_DIRECT', 'O_DIRECTORY', 'O_DSYNC', 'O_EXCL', 'O_LARGEFILE', 'O_NDELAY', 'O_NOATIME', 'O_NOCTTY', 'O_NOFOLLOW', 'O_NONBLOCK', 'O_PATH', 'O_RDONLY', 'O_RDWR', 'O_RSYNC', 'O_SYNC', 'O_TMPFILE', 'O_TRUNC', 'O_WRONLY', 'POSIX_FADV_DONTNEED', 'POSIX_FADV_NOREUSE', 'POSIX_FADV_NORMAL', 'POSIX_FADV_RANDOM', 'POSIX_FADV_SEQUENTIAL', 'POSIX_FADV_WILLNEED', 'PRIO_PGRP', 'PRIO_PROCESS', 'PRIO_USER', 'P_ALL', 'P_NOWAIT', 'P_NOWAITO', 'P_PGID', 'P_PID', 'P_WAIT', 'PathLike', 'RTLD_DEEPBIND', 'RTLD_GLOBAL', 'RTLD_LAZY', 'RTLD_LOCAL', 'RTLD_NODELETE', 'RTLD_NOLOAD', 'RTLD_NOW', 'RWF_DSYNC', 'RWF_HIPRI', 'RWF_NOWAIT', 'RWF_SYNC', 'R_OK', 'SCHED_BATCH', 'SCHED_FIFO', 'SCHED_IDLE', 'SCHED_OTHER', 'SCHED_RESET_ON_FORK', 'SCHED_RR', 'SEEK_CUR', 'SEEK_DATA', 'SEEK_END', 'SEEK_HOLE', 'SEEK_SET', 'ST_APPEND', 'ST_MANDLOCK', 'ST_NOATIME', 'ST_NODEV', 'ST_NODIRATIME', 'ST_NOEXEC', 'ST_NOSUID', 'ST_RDONLY', 'ST_RELATIME', 'ST_SYNCHRONOUS', 'ST_WRITE', 'TMP_MAX', 'WCONTINUED', 'WCOREDUMP', 'WEXITED', 'WEXITSTATUS', 'WIFCONTINUED', 'WIFEXITED', 'WIFSIGNALED', 'WIFSTOPPED', 'WNOHANG', 'WNOWAIT', 'WSTOPPED', 'WSTOPSIG', 'WTERMSIG', 'WUNTRACED', 'W_OK', 'XATTR_CREATE', 'XATTR_REPLACE', 'XATTR_SIZE_MAX', 'X_OK', '_Environ', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_execvpe', '_exists', '_exit', '_fspath', '_fwalk', '_get_exports_list', '_putenv', '_spawnvef', '_unsetenv', '_wrap_close', 'abc', 'abort', 'access', 'altsep', 'chdir', 'chmod', 'chown', 'chroot', 'close', 'closerange', 'confstr', 'confstr_names', 'cpu_count', 'ctermid', 'curdir', 'defpath', 'device_encoding', 'devnull', 'dup', 'dup2', 'environ', 'environb', 'error', 'execl', 'execle', 'execlp', 'execlpe', 'execv', 'execve', 'execvp', 'execvpe', 'extsep', 'fchdir', 'fchmod', 'fchown', 'fdatasync', 'fdopen', 'fork', 'forkpty', 'fpathconf', 'fsdecode', 'fsencode', 'fspath', 'fstat', 'fstatvfs', 'fsync', 'ftruncate', 'fwalk', 'get_blocking', 'get_exec_path', 'get_inheritable', 'get_terminal_size', 'getcwd', 'getcwdb', 'getegid', 'getenv', 'getenvb', 'geteuid', 'getgid', 'getgrouplist', 'getgroups', 'getloadavg', 'getlogin', 'getpgid', 'getpgrp', 'getpid', 'getppid', 'getpriority', 'getrandom', 'getresgid', 'getresuid', 'getsid', 'getuid', 'getxattr', 'initgroups', 'isatty', 'kill', 'killpg', 'lchown', 'linesep', 'link', 'listdir', 'listxattr', 'lockf', 'lseek', 'lstat', 'major', 'makedev', 'makedirs', 'minor', 'mkdir', 'mkfifo', 'mknod', 'name', 'nice', 'open', 'openpty', 'pardir', 'path', 'pathconf', 'pathconf_names', 'pathsep', 'pipe', 'pipe2', 'popen', 'posix_fadvise', 'posix_fallocate', 'pread', 'preadv', 'putenv', 'pwrite', 'pwritev', 'read', 'readlink', 'readv', 'register_at_fork', 'remove', 'removedirs', 'removexattr', 'rename', 'renames', 'replace', 'rmdir', 'scandir', 'sched_get_priority_max', 'sched_get_priority_min', 'sched_getaffinity', 'sched_getparam', 'sched_getscheduler', 'sched_param', 'sched_rr_get_interval', 'sched_setaffinity', 'sched_setparam', 'sched_setscheduler', 'sched_yield', 'sendfile', 'sep', 'set_blocking', 'set_inheritable', 'setegid', 'seteuid', 'setgid', 'setgroups', 'setpgid', 'setpgrp', 'setpriority', 'setregid', 'setresgid', 'setresuid', 'setreuid', 'setsid', 'setuid', 'setxattr', 'spawnl', 'spawnle', 'spawnlp', 'spawnlpe', 'spawnv', 'spawnve', 'spawnvp', 'spawnvpe', 'st', 'stat', 'stat_result', 'statvfs', 'statvfs_result', 'strerror', 'supports_bytes_environ', 'supports_dir_fd', 'supports_effective_ids', 'supports_fd', 'supports_follow_symlinks', 'symlink', 'sync', 'sys', 'sysconf', 'sysconf_names', 'system', 'tcgetpgrp', 'tcsetpgrp', 'terminal_size', 'times', 'times_result', 'truncate', 'ttyname', 'umask', 'uname', 'uname_result', 'unlink', 'unsetenv', 'urandom', 'utime', 'wait', 'wait3', 'wait4', 'waitid', 'waitid_result', 'waitpid', 'walk', 'write', 'writev']&gt;&gt;&gt; 查询帮助信息12help(os.CLD_DUMPED)q # 退出","link":"/2019/12/25/rpiPre3/"},{"title":"软件著作权申请指南","text":"记得当年第一次申请软件著作权，踩了很多坑，补了2次材料，拖了3个月才拿到手，今天又有东西需要提交来写一篇文档吧。 用户注册、线上申请网址 http://www.ccopyright.com.cn/==仅支持IE、360浏览器，并且打开兼容模式。firefox，chrome都不行== 申请步骤 官方文档： http://www.ccopyright.com.cn/index.php?optionid=1057 1. 阅读相关文件 文件汇总 http://www.ccopyright.com.cn/index.php?optionid=1003 2. 在线填报 填报模板范文：http://files.qianduan.ltd/muban.pdf 官方填报说明文档：http://www.ccopyright.com.cn/index.php?optionid=1081 3. 申请表打印、签字 打印下来的软件著作权申请表一定要确保两个事情 每一页申请表的最上面都应该有 页码、流水号,如果没有请把版权保护中心网站添加到兼容网站 申请人签字 4. 文件准备 官方说明文件 http://www.ccopyright.com.cn/index.php?optionid=1080 打印下来的 申请表(签章) 软件鉴别材料：软件源程序、文档 申请人若在源程序和文档页眉上标注了所申请软件的名称和版本号，应当与申请表中相应内容完全一致，==右上角应标注页码，源程序每页不少于50行==，最后一页应是程序的结束页，文档每页不少于30行，有图除外。如果源程序小于60页，请全部提交。大于60页提交前后30页。大概是这个样子： 身份证明材料营业执照、身份证。。。。。。。。（详见官方说明）。保证每个著作权人都有一个证明文件在上面 大于等于2个著作权人需要合作开发协议。给大家一个我自己写的模板 下载地址： http://files.qianduan.ltd/fb.docx 其他还有一些特殊需求的请仔细研读官方文档 最后大家提交申请材料清单的顺序填写并整理整齐、切勿装订。怕掉可以用个小夹子 5. 邮寄 地址：北京市西城区天桥南大街1号天桥艺术大厦A座三层302（邮编：100050）010-68003887 包裹上备注一下：软件登记部 6. 收证书版权保住中心邮寄的是邮政的挂号信，一般在制证10天附件就能收到，收不到自己去联系附近的邮政单位 7. 关于版权保护中心服务问题 大家在办理过程中可能发现基本打不通客服电话，请大家予以谅解。随着软件著作权申请的免费，工作人员每天需要处理大量文件，而且证书费、邮寄证书的快递费都不需要我们付费。体谅工作人员，即使查收邮件。希望大家申请顺利。","link":"/2019/12/26/ruanzhu/"},{"title":"树莓派实战（2）让小灯bling~bling~","text":"程序123456789import RPi.GPIO as GPIOimport time #引用time模块GPIO.setmode(GPIO.BOARD)GPIO.setup(7,GPIO.OUT)while True: GPIO.output(7,GPIO.HIGH) time.sleep(0.1) # 延时0.1秒 GPIO.output(7,GPIO.LOW) time.sleep(0.1) 知识点 相对于让小灯亮，让丫blingbling的亮只是多了个延时程序 引用 time 模块1import time time的功能还是很多的，但是在pi里面用到的（入门使用）不是太多，当然等玩的好了写个后台什么的会经常用到,我们暂且讨论两个 ==sleep== 和 ==clock== time.sleep(sec) 推迟调用线程的运行,实现程序的延时 1234import timeprint(&quot;开始&quot;)time.sleep(5)print(&quot;5秒后结束&quot;) 12345# 运行结果pi@raspberrypi:~/code $ python3 test3.py开始5秒后结束pi@raspberrypi:~/code $ time.clock() 就是经常将的时间戳，知道这玩意可以用来记录一段时间（比如程序运行的时间）就行 123# python 3.8以后会被禁用，可以换成 time.process_time pi@raspberrypi:~/code $ python3 test3.pytest3.py:2: DeprecationWarning: time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead 123456#实例程序import timetime1=time.process_time() # 返回第一个时间time.sleep(5)time2=time.process_time() # 中间那段程序跑完返回第二个时间print(time2-time1) #做差就是间隔时间 1234#运行结果pi@raspberrypi:~/code $ python3 test3.py5.557400000000268e-05pi@raspberrypi:~/code $","link":"/2019/12/25/rpiUse2/"},{"title":"centos7.x安装mongodb","text":"安装教程1:创建仓库1vi /etc/yum.repos.d/mongodb-org-3.4.repo 2：把下面的内容复制到文件中 保存退出123456[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc 3：yum安装1yum install -y mongodb-org 4：启动mogodb123systemctl start mongod.service //启动systemctl stop mongod.service //停止systemctl restart mongod.service //重启 5:设置开机自启动1systemctl enable mongod 6：链接mongodb1mongo 127.0.0.1:27017 7.如需修改配置文件（安装时不需修改）1vi /etc/mongod.conf 8.安装完成之后各种默认路径 MongoDB默认将数据文件存储在/var/lib/mongo目录 默认日志文件在/var/log/mongodb中如果要修改,可以在 /etc/mongod.conf 配置中指定备用日志和数据文件目录 MongoDB默认将数据文件存放在/var/lib/momgo目录 , 默认日志文件存在/var/log/mongodb/mongod.log目录, 如需修改可以在/etc/mongod.conf配置文件中指定目录 解决方法1.异常关闭重启服务器后连接失败解决方法mongod.lock文件 在mongodb的启动时，在数据目录下，会生成一个==mongod.lock==文件。mongod.lock文件存放的是启动mongod的进程号.如果在正常退出时，会清除这个mongod.lock文件，若要是异常退出，在下次启动的时候，会禁止启动，从而保留一份干净的一份副本数据。所以我们可以手动删除文件来解决这个问题 mongod.lock 一般是存储在数据文件目录下的,如果按照本文件安装mongodb，则路径是 ==/var/lib/mongo== 123/var/lib/mongo //进入数据目录ls -sh //查看此目录下所有文件 1rm mongod.lock 删除mongod.lock文件","link":"/2019/12/26/mongodbQuestions1/"}],"tags":[{"name":"电路","slug":"电路","link":"/tags/%E7%94%B5%E8%B7%AF/"},{"name":"arduino","slug":"arduino","link":"/tags/arduino/"},{"name":"cms配置","slug":"cms配置","link":"/tags/cms%E9%85%8D%E7%BD%AE/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"电子设计大赛","slug":"电子设计大赛","link":"/tags/%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"},{"name":"nodeJs","slug":"nodeJs","link":"/tags/nodeJs/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"软件著作权","slug":"软件著作权","link":"/tags/%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83/"}],"categories":[{"name":"电路","slug":"电路","link":"/categories/%E7%94%B5%E8%B7%AF/"},{"name":"arduino","slug":"arduino","link":"/categories/arduino/"},{"name":"cms配置","slug":"cms配置","link":"/categories/cms%E9%85%8D%E7%BD%AE/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"电子设计大赛","slug":"电子设计大赛","link":"/categories/%E7%94%B5%E5%AD%90%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"nodeJs","slug":"nodeJs","link":"/categories/nodeJs/"},{"name":"树莓派","slug":"树莓派","link":"/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"vscode","slug":"vscode","link":"/categories/vscode/"},{"name":"软件著作权","slug":"软件著作权","link":"/categories/%E8%BD%AF%E4%BB%B6%E8%91%97%E4%BD%9C%E6%9D%83/"}]}