{"pages":[{"title":"donate","text":"如果对您有帮助 请代我向中国红十字会捐赠 捐款地址 https://mv.lingxi360.com/m/zjgw7x?utm_bccid=LXEhue1n","link":"/donate/index.html"},{"title":"aboutMe","text":"个人简介 姓名 ：许许如生年龄：1999性别：男所在地：安徽合肥email: chenxu2656@gmail.com教育经历 2016- 安徽医科大学 生物医学工程 （Biomedical engineering ， AnHui Medical University）技能及爱好 arduino、树莓派、前端、小程序项目经历 2018- 今 图形化编程应用平台2018- 今 图形化编程平台（面向前端开发）2019.4-今 基于webplus站群的前端主题开发 安徽医科大学财务处 安徽医科大学南校区管委会 安徽医科大学人事处 安徽医科大学纪委办公室 安徽医科大学留学生网 2019.7 用于小型场所（实验室）电子元器件及设备管理小程序 github： https://github.com/chenxu2656/celwx 其他 考研估计要凉，学学前端找工作啦！！！","link":"/about/index.html"}],"posts":[{"title":"docker常用命令","text":"查询镜像1docker search IMAGENAME 下载镜像 1docker pull IMAGENAME 查询已下载镜像 1docker images 查询容器列表 1docker ps 删除一个容器实例 1sudo docker rm CONTAINERID 删除所有容器 1sudo docker rm sudo docker ps -aq 停止一个正在运行的容器 1sudo docker kill CONTAINERID 重启一个正在运行的容器 1sudo docker restart CONTAINERID 开启一个已经停止的容器 1sudo docker start CONTAINERID 删除镜像，从本地删除一个已经下载的镜像 先查看正在运行的 容器 1docker ps 结束正在运行的容器 1docker kill containerid 删除正在运行的容器 1docker rm CONTAINERID 删除镜像 1docker rmi imageid ==注意 rm 和 rmi 分别用来删除容器和镜像== 退出当前镜像1exit","link":"/2019/12/25/docker2/"},{"title":"docker修改映射端口号","text":"大家都知道docker run可以指定端口映射，但是容器一旦生成，就没有一个命令可以直接修改。通常间接的办法是，保存镜像，再创建一个新的容器，在创建时指定新的端口映射,但是这种方法比较麻烦。牛人还是有奇招的：https://stackoverflow.com/questions/19335444/how-do-i-assign-a-port-mapping-to-an-existing-docker-container 停止容器 1docker stop containerID 停止docker服务 1systemctl stop docker 修改这个容器的hostconfig.json文件中的端口（如果有多个版本都需要修改） centos一般默认的docker container目录在这进入这个目录 1cd /var/lib/docker/containers/8bee1db654916998ae2e4c716481209f290d521b74dc997bbd37cb8d9f856cc4 1vi hostconfig.json 修改下面这个端口号就行，这里我已经修改过了 启动docker服务1systemctl start docker 5) 启动容器 1docker start containerID 如果修改完之后没有正常运行，请检查原有的服务是否开启，因为有时有的服务需要重启一下","link":"/2019/12/25/docker3/"},{"title":"树莓派使用基础教程（1）系统安装及远程登陆","text":"系统安装 树莓派提供了系统安装工具NOOBS 1. 进入下载页面 左侧是 图形化界面的系统、右侧是不带图形化界面的系统，没什么区别 https://www.raspberrypi.org/downloads/ 我们选右边这个，高级一点 2. 选择一种方式下载（迅雷好像快一点） 网盘我也存了一份：https://pan.baidu.com/s/1QFVUocKJpe1QmxssRWuRHg 3. 解压 解压下来是这个样子，目录不要含有中文，不然做系统盘会出错 4. 格式化sd卡，格式化成FAT 感觉格式化完内存显示有问题用磁盘管理工具重新分一下区然后重新格式化 5. 下载系统写入工具 推荐使用 diskimage，扔个CDN加速的下载链接给你：http://files.qianduan.ltd/win32diskimager-1.0.0-install.exe 6. 写入系统文件 7. emmm快成功了通过ssh链接1. 在boot目录下写入 SSH文件2. 在根目录下新建```12 country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network={ ssid=”WiFi-A” psk=”12345678” key_mgmt=WPA-PSK priority=1} 12345678910111213141516171819202122&gt; #ssid:网络的ssid&gt; #psk:密码&gt; #priority:连接优先级，数字越大优先级越高（不可以是负数）&gt; #scan_ssid:连接隐藏WiFi时需要指定该值为1&gt; #key_mgmt:加密方式 （进路由器后台看）&gt;&gt; ``` key_mgmt=WPA-PSK ``` :使用WPA/WPA2加密(一般都是这个)&gt;&gt; ``` key_mgmt=NONE ``` ：WEP加密![image](http://image.qianduan.ltd/s10.png)#### 3. 把sd卡安装至卡槽，上电启动#### 4. 查看树莓派IP &gt; 1. 可以通过路由器后台查看![image](http://image.qianduan.ltd/s5.png)&gt; 2. 用命令ping一下``` ping -4 raspberrypi 默认ping出的是IPV6，所以加个 -4 强制转换一下 5. 下载个远程登陆工具 xshell （相对较专业）和 putty（开源轻便） 选一个：https://qdzy.xccstu.top/qdzy/site/yzrj.html 6. 登录 输入刚才ping到的IP 默认用户名：pi 默认密码：raspberry","link":"/2019/12/25/rpiPre1/"},{"title":"centos7配置docker","text":"docker主要分为两个版本 docker CE (社区免费版) docker EE(收费版本)，我们使用社区免费版就行 安装一些必要的系统工具： 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息： 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存： 1sudo yum makecache fast 安装 Docker-ce： 1sudo yum -y install docker-ce 启动 Docker 后台服务 1sudo systemctl start docker 测试运行 hello-world 1docker run hello-world (先自动安装helloword的库然后运行) 查询docker版本 1docker -v","link":"/2019/12/25/docker1/"},{"title":"树莓派使用基础教程（2）系统安装及远程登陆","text":"1. 查询raspberrypi自带python版本 python2版本 2.7.16（默认使用） python3版本 3.7.3 退出python ：CTRL+D 2. 添加注释1# 3. 变量 区分大小写 ==实际没有变量实际是对变量对象的引用== 避免变量名与关键字重复 123456789# 查看关键字pi@raspberrypi:~/code $ python3Python 3.7.3 (default, Apr 3 2019, 05:39:12) [GCC 8.2.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import keyword&gt;&gt;&gt; print(keyword.kwlist)['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']&gt;&gt;&gt; 变量名第一个字符只能是字母和下划线 长（多）字符串赋值 查询变量类型 1type(变量名) 4. 运算 普通运算和别的语言一样特殊运算1. 分数对象 ==Fraction==12from fractions import Fraction #引入模块创建对象test = Fraction(分子,分母) #创建的分数对象可以进行数字运算 实例 12345&gt;&gt;&gt; from fractions import Fraction&gt;&gt;&gt; test=Fraction(2,6)&gt;&gt;&gt; print(test)1/3&gt;&gt;&gt; 2. 复数操作 3. math模块 和别的函数的math对象基本相同https://blog.csdn.net/iamaiearner/article/details/9381347整体引入 12import math #引入模块math.funcname() #调用 单个引入 12from math import funcname # 引入单个模块funcname( ) # 直接调用 4. 数组处理 NumPy模块1import numpy 5. 控制语句 没什么特别的 强依赖缩进+冒号 1234if: print()else: print() 6. 循环语句 语法结构和js相似， 强依赖缩进+冒号 12345# for in 循环for the_number in [1,2,3,4,5]:### . 常用命令#### 1. print() python3 print(argument) 12345678910- 字符&gt; 单引号或者双引号&gt; 三重引号实现带格式输出 (使用转义符\\n效果一样)![image](http://image.qianduan.ltd/po1.png)&gt; 代码``` print(&quot;&quot;&quot; 第一行 第二行 第三行&quot;&quot;&quot;) 输出 12345pi@raspberrypi:~/code $ python3 test3.py 第一行 第二行 第三行","link":"/2019/12/25/rpiPre2/"},{"title":"树莓派使用基础教程（3）文件操作","text":"1. 操作文件 主要针对文本文件 文件常用命令 (python) 查询当前目录文件 123&gt;&gt;&gt; os.listdir()['test2.py', 'test1.py', 'test3.py']&gt;&gt;&gt; 创建文件 1234&gt;&gt;&gt; import os&gt;&gt;&gt; filename=&quot;test4.py&quot;&gt;&gt;&gt; os.mknod(filename)&gt;&gt;&gt; 修改文件名 12&gt;&gt;&gt; os.rename(&quot;test4.py&quot;,&quot;test5.py&quot;)&gt;&gt;&gt; 删除文件 12&gt;&gt;&gt; os.remove(&quot;test5.py&quot;)&gt;&gt;&gt; 打开文件 1&gt;&gt;&gt; test=open(&quot;test.txt&quot;) 写入文件 123456789101112131415&gt;&gt;&gt; test=open(&quot;test.txt&quot;) # 打开文件&gt;&gt;&gt; testnum=10 #定义写入变量&gt;&gt;&gt; test.write(testnum) #写入函数 openTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: write() argument must be str, not int # 报错，写入文件类型只能是数字&gt;&gt;&gt; teststring=&quot;123456&quot; # 写一个字符串重新写入&gt;&gt;&gt; test.write(teststring)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;io.UnsupportedOperation: not writable #再次报错，文件只读 &gt;&gt;&gt; test=open(&quot;test.txt&quot;,&quot;w&quot;) #重新打开文件，mode写成 “w” “a”不会擦除 可写。但是w会移除原有内容&gt;&gt;&gt; test.write(teststring)6&gt;&gt;&gt; 读取文件 1234567&gt;&gt;&gt; testread=open(&quot;test.txt&quot;,&quot;r&quot;)&gt;&gt;&gt; test_data=testread()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '_io.TextIOWrapper' object is not callable&gt;&gt;&gt; test_data=testread.read()&gt;&gt;&gt; print(test_data) 2. 函数 定义函数 1234def funcname(): statement1 #参数 statement2 return value #返回值 调用函数1funcname() 设定参数默认值1def funcname(width,height=20): 3. 模块 列出一个模块所有函数1234&gt;&gt;&gt; import os &gt;&gt;&gt; dir(os) #列出所有函数['CLD_CONTINUED', 'CLD_DUMPED', 'CLD_EXITED', 'CLD_TRAPPED', 'DirEntry', 'EX_CANTCREAT', 'EX_CONFIG', 'EX_DATAERR', 'EX_IOERR', 'EX_NOHOST', 'EX_NOINPUT', 'EX_NOPERM', 'EX_NOUSER', 'EX_OK', 'EX_OSERR', 'EX_OSFILE', 'EX_PROTOCOL', 'EX_SOFTWARE', 'EX_TEMPFAIL', 'EX_UNAVAILABLE', 'EX_USAGE', 'F_LOCK', 'F_OK', 'F_TEST', 'F_TLOCK', 'F_ULOCK', 'GRND_NONBLOCK', 'GRND_RANDOM', 'MutableMapping', 'NGROUPS_MAX', 'O_ACCMODE', 'O_APPEND', 'O_ASYNC', 'O_CLOEXEC', 'O_CREAT', 'O_DIRECT', 'O_DIRECTORY', 'O_DSYNC', 'O_EXCL', 'O_LARGEFILE', 'O_NDELAY', 'O_NOATIME', 'O_NOCTTY', 'O_NOFOLLOW', 'O_NONBLOCK', 'O_PATH', 'O_RDONLY', 'O_RDWR', 'O_RSYNC', 'O_SYNC', 'O_TMPFILE', 'O_TRUNC', 'O_WRONLY', 'POSIX_FADV_DONTNEED', 'POSIX_FADV_NOREUSE', 'POSIX_FADV_NORMAL', 'POSIX_FADV_RANDOM', 'POSIX_FADV_SEQUENTIAL', 'POSIX_FADV_WILLNEED', 'PRIO_PGRP', 'PRIO_PROCESS', 'PRIO_USER', 'P_ALL', 'P_NOWAIT', 'P_NOWAITO', 'P_PGID', 'P_PID', 'P_WAIT', 'PathLike', 'RTLD_DEEPBIND', 'RTLD_GLOBAL', 'RTLD_LAZY', 'RTLD_LOCAL', 'RTLD_NODELETE', 'RTLD_NOLOAD', 'RTLD_NOW', 'RWF_DSYNC', 'RWF_HIPRI', 'RWF_NOWAIT', 'RWF_SYNC', 'R_OK', 'SCHED_BATCH', 'SCHED_FIFO', 'SCHED_IDLE', 'SCHED_OTHER', 'SCHED_RESET_ON_FORK', 'SCHED_RR', 'SEEK_CUR', 'SEEK_DATA', 'SEEK_END', 'SEEK_HOLE', 'SEEK_SET', 'ST_APPEND', 'ST_MANDLOCK', 'ST_NOATIME', 'ST_NODEV', 'ST_NODIRATIME', 'ST_NOEXEC', 'ST_NOSUID', 'ST_RDONLY', 'ST_RELATIME', 'ST_SYNCHRONOUS', 'ST_WRITE', 'TMP_MAX', 'WCONTINUED', 'WCOREDUMP', 'WEXITED', 'WEXITSTATUS', 'WIFCONTINUED', 'WIFEXITED', 'WIFSIGNALED', 'WIFSTOPPED', 'WNOHANG', 'WNOWAIT', 'WSTOPPED', 'WSTOPSIG', 'WTERMSIG', 'WUNTRACED', 'W_OK', 'XATTR_CREATE', 'XATTR_REPLACE', 'XATTR_SIZE_MAX', 'X_OK', '_Environ', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_execvpe', '_exists', '_exit', '_fspath', '_fwalk', '_get_exports_list', '_putenv', '_spawnvef', '_unsetenv', '_wrap_close', 'abc', 'abort', 'access', 'altsep', 'chdir', 'chmod', 'chown', 'chroot', 'close', 'closerange', 'confstr', 'confstr_names', 'cpu_count', 'ctermid', 'curdir', 'defpath', 'device_encoding', 'devnull', 'dup', 'dup2', 'environ', 'environb', 'error', 'execl', 'execle', 'execlp', 'execlpe', 'execv', 'execve', 'execvp', 'execvpe', 'extsep', 'fchdir', 'fchmod', 'fchown', 'fdatasync', 'fdopen', 'fork', 'forkpty', 'fpathconf', 'fsdecode', 'fsencode', 'fspath', 'fstat', 'fstatvfs', 'fsync', 'ftruncate', 'fwalk', 'get_blocking', 'get_exec_path', 'get_inheritable', 'get_terminal_size', 'getcwd', 'getcwdb', 'getegid', 'getenv', 'getenvb', 'geteuid', 'getgid', 'getgrouplist', 'getgroups', 'getloadavg', 'getlogin', 'getpgid', 'getpgrp', 'getpid', 'getppid', 'getpriority', 'getrandom', 'getresgid', 'getresuid', 'getsid', 'getuid', 'getxattr', 'initgroups', 'isatty', 'kill', 'killpg', 'lchown', 'linesep', 'link', 'listdir', 'listxattr', 'lockf', 'lseek', 'lstat', 'major', 'makedev', 'makedirs', 'minor', 'mkdir', 'mkfifo', 'mknod', 'name', 'nice', 'open', 'openpty', 'pardir', 'path', 'pathconf', 'pathconf_names', 'pathsep', 'pipe', 'pipe2', 'popen', 'posix_fadvise', 'posix_fallocate', 'pread', 'preadv', 'putenv', 'pwrite', 'pwritev', 'read', 'readlink', 'readv', 'register_at_fork', 'remove', 'removedirs', 'removexattr', 'rename', 'renames', 'replace', 'rmdir', 'scandir', 'sched_get_priority_max', 'sched_get_priority_min', 'sched_getaffinity', 'sched_getparam', 'sched_getscheduler', 'sched_param', 'sched_rr_get_interval', 'sched_setaffinity', 'sched_setparam', 'sched_setscheduler', 'sched_yield', 'sendfile', 'sep', 'set_blocking', 'set_inheritable', 'setegid', 'seteuid', 'setgid', 'setgroups', 'setpgid', 'setpgrp', 'setpriority', 'setregid', 'setresgid', 'setresuid', 'setreuid', 'setsid', 'setuid', 'setxattr', 'spawnl', 'spawnle', 'spawnlp', 'spawnlpe', 'spawnv', 'spawnve', 'spawnvp', 'spawnvpe', 'st', 'stat', 'stat_result', 'statvfs', 'statvfs_result', 'strerror', 'supports_bytes_environ', 'supports_dir_fd', 'supports_effective_ids', 'supports_fd', 'supports_follow_symlinks', 'symlink', 'sync', 'sys', 'sysconf', 'sysconf_names', 'system', 'tcgetpgrp', 'tcsetpgrp', 'terminal_size', 'times', 'times_result', 'truncate', 'ttyname', 'umask', 'uname', 'uname_result', 'unlink', 'unsetenv', 'urandom', 'utime', 'wait', 'wait3', 'wait4', 'waitid', 'waitid_result', 'waitpid', 'walk', 'write', 'writev']&gt;&gt;&gt; 查询帮助信息12help(os.CLD_DUMPED)q # 退出","link":"/2019/12/25/rpiPre3/"},{"title":"树莓派使用基础教程（4）自定义模块调用","text":"先创建一个自定义模块 123# libtest.pydef AaaB(): print(&quot;happy~&quot;) 库文件调用1. 同目录调用 test5.py libtest.py 123# test5.py codeimport libtest # 引入模块文件libtest.AaaB() # 运行相应函数 2. 不同目录下调用 为了不让文件过于混乱，通常新建一个lib的文件夹，即目录以如下方式呈现 test5.py lib libtest.py 12345# test5.py codeimport syssys.path.append(&quot;/home/pi/code/lib&quot;) # 绝对目录import libtestlibtest.AaaB()","link":"/2019/12/25/rpiPre4/"},{"title":"树莓派实战（1）：点亮小灯","text":"就像学习哦计算机语言第一步往往是输出一个 hello world一样，玩板子第一步一定是点个灯 程序12345import RPi.GPIO as GPIOGPIO.setmode(GPIO.BOARD)GPIO.setup(7,GPIO.OUT)while True: GPIO.output(7,GPIO.HIGH) 知识点树莓派使用的是GPIO的模块用来控制引脚，所谓GPIO也就是==general-purpose input/output==通用输入输出接口123# 1. 引入 GPIO模块import RPi.GPIO as GPIO GPIO控制引脚的编码方式主要有三种 按照插座编号编码 （==header==） BCM编号方式(==BCM GPIO==) wiringPi编号方式 (==wiringPi==) 一般采用第一种或者第二种那个习惯用哪个，第三种主要注重逻辑，可以但没必要。 12345# 编号方式设定GPIO.setmode(GPIO.BOARD) #第一种GPIO.setmode(GPIO.BCM) # 第二种 设置通道工作方式123#用作输入GPIO.setup(channel, GPIO.IN) 1234#用作输出GPIO.setup(channel, GPIO.OUT) GPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH) #为引脚设置默认值 设置通道的逻辑值123456# 输入通道GPIO.input(channel) #读取通过的逻辑值，比如按键事件# 返回0 / GPIO.LOW / False or 1 / GPIO.HIGH / True. 1234567891011121314#输出通道GPIO.output(channel, state)# statue：GPIO.HIGH / GPIO.LOW也可以同时设置多个通道输出chan_list = [11,12] GPIO.output(chan_list, GPIO.LOW) GPIO.output(chan_list, (GPIO.HIGH, GPIO.LOW))# 第一个11是高电平、12是低电平 清空引脚1GPIO.cleanup()","link":"/2019/12/25/rpiUse1/"},{"title":"树莓派实战（2）让小灯bling~bling~","text":"程序123456789import RPi.GPIO as GPIOimport time #引用time模块GPIO.setmode(GPIO.BOARD)GPIO.setup(7,GPIO.OUT)while True: GPIO.output(7,GPIO.HIGH) time.sleep(0.1) # 延时0.1秒 GPIO.output(7,GPIO.LOW) time.sleep(0.1) 知识点 相对于让小灯亮，让丫blingbling的亮只是多了个延时程序 引用 time 模块1import time time的功能还是很多的，但是在pi里面用到的（入门使用）不是太多，当然等玩的好了写个后台什么的会经常用到,我们暂且讨论两个 ==sleep== 和 ==clock== time.sleep(sec) 推迟调用线程的运行,实现程序的延时 1234import timeprint(&quot;开始&quot;)time.sleep(5)print(&quot;5秒后结束&quot;) 12345# 运行结果pi@raspberrypi:~/code $ python3 test3.py开始5秒后结束pi@raspberrypi:~/code $ time.clock() 就是经常将的时间戳，知道这玩意可以用来记录一段时间（比如程序运行的时间）就行 123# python 3.8以后会被禁用，可以换成 time.process_time pi@raspberrypi:~/code $ python3 test3.pytest3.py:2: DeprecationWarning: time.clock has been deprecated in Python 3.3 and will be removed from Python 3.8: use time.perf_counter or time.process_time instead 123456#实例程序import timetime1=time.process_time() # 返回第一个时间time.sleep(5)time2=time.process_time() # 中间那段程序跑完返回第二个时间print(time2-time1) #做差就是间隔时间 1234#运行结果pi@raspberrypi:~/code $ python3 test3.py5.557400000000268e-05pi@raspberrypi:~/code $","link":"/2019/12/25/rpiUse2/"},{"title":"树莓派实战（3）按键控制小灯","text":"程序12345678910import RPi.GPIO as GPIO GPIO.setmode(GPIO.BOARD) #引脚编码方式GPIO.setup(7,GPIO.OUT,initial=GPIO.LOW) # 小灯，7号引脚，默认不亮,输出GPIO.setup(11,GPIO.IN) # 按键读取while True: statue=GPIO.input(11) # 读取按键是否被按下 if statue==1: GPIO.output(7, GPIO.HIGH) else: GPIO.output(7, GPIO.LOW) 接线图 知识点 程序控制语句 if else注意书写格式就行","link":"/2019/12/25/rpiUse3/"},{"title":"Javascript选择器","text":"1. 获取某个Id1getElementById('idName'); 2. 获取某个 ClasaName1getElementByClassName() 3. 根据标签名获取返回的是一个伪数组 1getElementByTagName() 4. 获取body 返回的是 节点 1Document.body 5. 获取html对于任何非空 HTML 文档，调用 document.documentElement 总是会返回一个 元素，且它一定是该文档的根元素。借助这个只读属性，能方便地获取到任意文档的根元素。 1document.documentElement 6. querySelector需要指明name的具体属性 比如 #name .name 等返回的是制定选择器的第一个元素对象 1querySelector(&quot;name&quot;) 7. querySelectorAll需要指明name的具体属性 比如 #name .name 等返回的是制定选择器所有对象集合（一个数组） 1querySelectorAll(&quot;name&quot;)","link":"/2019/12/26/javascript1/"},{"title":"js鼠标事件汇总","text":"1. js鼠标事件汇总 onclick&amp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当用户点击某个对象时调用的事件句柄。 oncontextmenu &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在用户点击鼠标右键打开上下文菜单时触发 ondblclick &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户双击某个对象时调用的事件句柄。 onmousedown &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标按钮被按下。 onmouseenter &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当鼠标指针移动到元素上时触发。 onmouseleave &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当鼠标指针移出元素时触发 onmousemove &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标被移动。 onmouseover &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标移到某元素之上。 onmouseout &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标从某元素移开。 onmouseup &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标按键被松开。 2. 事件触发事件源+事件类型+事件处理程序 12345var shijianyuan = document.getElementById('tijiao'); // 事件源shijianyuan.onclick = function(event){ // onclick 为事件触发类型 // function 内为事件触发函数} 3. 触发时的参数event为MouseEvent对象类型： type &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事件类型，如’mosemove’或者’mousedown’ button&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整型，触发鼠标事件时按下的按钮编号 buttons&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整型，触发鼠标事件时弹起来的按钮编号 [x]clientX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在DOM内容区的X坐标 [x]X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上 [x]clientY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在DOM内容区的Y坐标 [x]Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上 [x]offsetX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针相对父节点填充边缘的X坐标 [x]offsetY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 鼠标指针相对父节点填充边缘的Y坐标 [x]screenX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在全局屏幕的X坐标 [x]screenY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在全局屏幕的Y坐标 [x]pageX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在整个DOM内容（包括分页）的X坐标 [x]pageY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鼠标指针在整个DOM内容（包括分页）的Y坐标 [x]altKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的alt键和鼠标是否同时按下 [x]ctrKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的alt键和鼠标是否同时按下 [x]shiftKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，表示此时的shift键是和鼠标是否同时按下 [x]metaKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;布尔值，windows平台表示Window键是否同时按下，mac表示Command键是否同时按下 12345678910# 示例程序返回点击时鼠标的坐标&lt;body&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log(MouseEvent.x); } &lt;/script&gt;&lt;/body&gt; 4. offsetY 、 screenY 、 clientY (y) 、 pageY的区别12345678910111213141516&lt;body style=&quot;height: 2000px;&quot;&gt; &lt;html&gt; &lt;div style=&quot;width: 500px; height: 500px; background-color: aqua; margin: 200px auto auto 200px; padding: 100px;&quot;&gt; &lt;div style=&quot;width: 200px; height: 200px; background-color: brown;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/html&gt; &lt;script&gt; document.onclick = function (MouseEvent){ console.log('clienty的坐标是'+MouseEvent.y); console.log('pagey的坐标是'+MouseEvent.pageY); console.log('offsety的坐标是'+MouseEvent.offsetY); console.log('screeny的坐标是'+MouseEvent.screenY); } &lt;/script&gt;&lt;/body&gt; 运行结果 offsetY相对于父节点的位置而言 screenY相对于整个显示器的位置而言 clientY相对于当前页面的位置而言 offsetY相对于当前页面+纵向滚动距离（）的位置而言","link":"/2019/12/26/mouse/"}],"tags":[{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"}],"categories":[{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"树莓派","slug":"树莓派","link":"/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"}]}